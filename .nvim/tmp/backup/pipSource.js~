/*
*
* Copyright (c) 2011-2014- Justin Dearing (zippy1981@gmail.com)
* Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
* and GPL (http://www.opensource.org/licenses/gpl-license.php) version 2 licenses.
* This software is not distributed under version 3 or later of the GPL.
*
* Version 1.0.2
*
*/
var ObjectId;
(function (ObjectId) {
    function create(arg) {
        return new Obj(arg).toString();
    }
    ObjectId.create = create;
    function Obj(arg) {
        var increment = 0;
        var pid = Math.floor(Math.random() * (32767));
        var machine = Math.floor(Math.random() * (16777216));
        if (typeof (localStorage) != 'undefined') {
            var mongoMachineId = parseInt(localStorage['mongoMachineId']);
            if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {
                machine = Math.floor(localStorage['mongoMachineId']);
            }
            localStorage['mongoMachineId'] = machine;
            document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT';
        }
        else {
            var cookieList = document.cookie.split('; ');
            for (var i in cookieList) {
                var cookie = cookieList[i].split('=');
                if (cookie[0] == 'mongoMachineId' && parseInt(cookie[1], 10) >= 0 && parseInt(cookie[1], 10) <= 16777215) {
                    machine = parseInt(cookie[1], 10);
                    break;
                }
            }
            document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT';
        }
        if (typeof arg == 'string' && arg.length == 24) {
            this.timestamp = Number('0x' + arg.substr(0, 8)),
                this.machine = Number('0x' + arg.substr(8, 6)),
                this.pid = Number('0x' + arg.substr(14, 4)),
                this.increment = Number('0x' + arg.substr(18, 6));
        }
        else {
            this.timestamp = Math.floor(new Date().valueOf() / 1000);
            this.machine = machine;
            this.pid = pid;
            this.increment = increment++;
            if (increment > 0xffffff) {
                increment = 0;
            }
        }
    }
    Obj.prototype.getDate = function () {
        return new Date(this.timestamp * 1000);
    };
    Obj.prototype.toArray = function () {
        var strOid = this.toString();
        var array = [];
        var i;
        for (i = 0; i < 12; i++) {
            array[i] = parseInt(strOid.slice(i * 2, i * 2 + 2), 16);
        }
        return array;
    };
    Obj.prototype.toString = function () {
        var timestamp = this.timestamp.toString(16);
        var machine = this.machine.toString(16);
        var pid = this.pid.toString(16);
        var increment = this.increment.toString(16);
        return '00000000'.substr(0, 8 - timestamp.length) + timestamp +
            '000000'.substr(0, 6 - machine.length) + machine +
            '0000'.substr(0, 4 - pid.length) + pid +
            '000000'.substr(0, 6 - increment.length) + increment;
    };
})(ObjectId || (ObjectId = {}));

var DOMIO;
(function (DOMIO) {
    var IO = Monads.IO;
    var OV = Globals.OptionValue;
    DOMIO.create = R.curryN(1, function (scope) {
        return ((scope instanceof IO) && scope.fn)
            ? scope
            : IO.of($(scope));
    });
    DOMIO.createScoped = R.curryN(2, function (scope, selector) {
        return R.is(String, scope) || !R.is(IO, scope)
            ? IO.of($(scope).children(selector))
            : scope.map(function ($el) { return $($el).children(selector); });
    });
    function remove($elem) {
        return $elem.remove();
    }
    DOMIO.remove = remove;
    function detach($elem) {
        return $elem.detach();
    }
    DOMIO.detach = detach;
    DOMIO.mapItems = R.curry(function (fn, io) {
        var result = [];
        io.map(function ($elem) {
            $elem.map(function () {
                var io = DOMIO.create(this);
                result.push(io.map(fn).runIO());
            });
        }).runIO();
        return result;
    });
    DOMIO.addClass = R.curry(function (name, $elem) {
        return $elem.addClass(name);
    });
    DOMIO.removeClass = R.curry(function (name, $elem) {
        return $elem.removeClass(name);
    });
    DOMIO.addCss = R.curry(function (attr, $elem) {
        return $elem.css.call($elem, attr.attr, attr.value);
    });
    DOMIO.addAttr = R.curry(function (attr, $elem) {
        return $elem.attr.apply($elem, R.flatten(R.toPairs(attr)));
    });
    DOMIO.getAttr = R.curry(function (attrName, $elem) {
        return $elem.attr(attrName);
    });
    DOMIO.addProp = R.curry(function (prop, $elem) {
        return $elem.prop.call($elem, prop, true);
    });
    DOMIO.removeProp = R.curry(function (prop, $elem) {
        return $elem.prop.call($elem, prop, false);
    });
    DOMIO.getProp = R.curry(function (prop, $elem) {
        return $elem.prop(prop);
    });
    var cleanHref = function (href) {
        if (!href) {
            return '';
        }
        var tail = R.last(href.split('/'));
        if (tail) {
            tail = R.last(tail.split('#'));
        }
        return tail;
    };
    DOMIO.getDOMItemId = R.curry(function (idType, $elem) {
        var itemId = '';
        switch (idType) {
            case 'href':
                if ($elem[0].tagName === 'A') {
                    itemId = cleanHref($elem.attr('href'));
                }
                else {
                    itemId = cleanHref($elem.find('a').attr('href'));
                }
                if (!itemId) {
                    itemId = cleanHref($elem.closest('a').attr('href'));
                }
                break;
            default:
                itemId = $elem.attr(idType);
                if (!itemId) {
                    itemId = $elem.find(":contains(" + idType + ")").attr(idType);
                }
        }
        return itemId;
    });
    DOMIO.setVal = R.curryN(2, function (value, $elem) {
        return $elem.val(value);
    });
    function getVal($elem) {
        return Utils.trim($elem.val());
    }
    DOMIO.getVal = getVal;
    DOMIO.preventDefault = function (evt) {
        evt.preventDefault();
    };
    function addEvent(eventName, selector, data, method) {
        if (R.is(Array, selector)) {
            method = data;
            data = selector;
            return function ($elem) {
                return $elem.on(eventName, data, method);
            };
        }
        else {
            return function ($elem) {
                return $elem.on(eventName, selector, data, method);
            };
        }
    }
    DOMIO.addEvent = addEvent;
    function removeEvent(event, selector) {
        if (selector == null) {
            return function ($elem) {
                return $elem.off(event);
            };
        }
        else {
            return function ($elem, selector) {
                return $elem.off(event, selector);
            };
        }
    }
    DOMIO.removeEvent = removeEvent;
    DOMIO.html = R.curryN(2, function (tplString, $elem) {
        return $elem.html(tplString);
    });
    DOMIO.prependString = R.curryN(2, function (tplString, $elem) {
        return $elem.prepend(tplString);
    });
    DOMIO.appendString = R.curryN(2, function (tplString, $elem) {
        return $elem.append(tplString);
    });
    DOMIO.prependElement = R.curryN(2, function ($parent, $child) {
        return $parent.prepend($child);
    });
    DOMIO.appendElement = R.curryN(2, function ($parent, $child) {
        return $parent.append($child);
    });
    DOMIO.insertBeforeElement = R.curryN(2, function ($target, $sibling) {
        return $sibling.insertBefore($target);
    });
    DOMIO.insertAfterElement = R.curryN(2, function ($target, $sibling) {
        return $sibling.insertAfter($target);
    });
    DOMIO.unPrependElement = R.curryN(2, function ($parent, $child) {
        return $parent.children().not($child).first().remove();
    });
    DOMIO.unAppendElement = R.curryN(2, function ($parent, $child) {
        return $parent.children().not($child).last().remove();
    });
    DOMIO.wrapElement = R.curryN(2, function ($parent, $element) {
        return $parent.wrap($element);
    });
    DOMIO.unWrapElement = R.curryN(1, function ($element) {
        return $element.unwrap();
    });
    DOMIO.removeElement = R.curryN(2, function ($parent, $child) {
        if ($child.length === 0)
            return;
        var selector = $child.selector;
        if (selector === "") {
            var id = $child.attr("id"), name_1 = $child.attr('name'), classes = $child.attr('class');
            if (id)
                return $parent.children(selector).remove();
            if (name_1)
                return $parent.children(selector).remove();
            if (classes)
                return $parent.children('.' + R.join(' .', R.split(' ', classes))).remove();
            return $parent.children($child[0].tagName).remove();
        }
        else {
            return $parent.children(selector).remove();
        }
    });
    function detachElement($elem) {
        return DOMIO.create($elem.detach());
    }
    DOMIO.detachElement = detachElement;
    DOMIO.empty = function ($elem) {
        return $elem.empty();
    };
    function manipulate($anc, method, $chunk) {
        switch (method) {
            case OV.prepend:
                $anc.chain(function (r) {
                    return R.map(function (t) {
                        return DOMIO.prependElement(r, t);
                    }, $chunk);
                }).runIO();
                break;
            case OV.append:
                $anc.chain(function (r) {
                    return R.map(function (t) {
                        return DOMIO.appendElement(r, t);
                    }, $chunk);
                }).runIO();
                break;
            case OV.unPrepend:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.unPrependElement(a, c);
                    }, $chunk);
                }).runIO();
                break;
            case OV.unAppend:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.unAppendElement(a, c);
                    }, $chunk);
                }).runIO();
                break;
            case OV.insertBefore:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.insertBeforeElement(a, c);
                    }, $chunk);
                }).runIO();
                break;
            case OV.insertAfter:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.insertAfterElement(a, c);
                    }, $chunk);
                }).runIO();
                break;
            case OV.remove:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.removeElement(a, c);
                    }, $chunk);
                }).runIO();
                break;
            case OV.wrap:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.wrapElement(a, c);
                    }, $chunk);
                }).runIO();
                break;
            default:
                $anc.chain(function (a) {
                    return R.map(function (c) {
                        return DOMIO.unWrapElement(a, c);
                    }, $chunk);
                }).runIO();
        }
    }
    DOMIO.manipulate = manipulate;
})(DOMIO || (DOMIO = {}));

var Globals;
(function (Globals) {
    Globals.IT = '__it', Globals.POS = '__pos', Globals.MERGETOKEN = '%%', Globals.NO_TARGET = 'NO_TARGET', Globals.IS_TARGET = 'IS_TARGET', Globals.IS_UNSELECTED = 'IS_UNSELECTED', Globals.IS_SELECTED = 'IS_SELECTED', Globals.serverAddress = "http://localhost:9090/", Globals.defaultEvents = 'click touchstart', Globals.serverIndexAttr = '_id';
    (function (ApplyType) {
        ApplyType[ApplyType["cl"] = 0] = "cl";
        ApplyType[ApplyType["attr"] = 1] = "attr";
        ApplyType[ApplyType["prop"] = 2] = "prop";
        ApplyType[ApplyType["css"] = 3] = "css";
    })(Globals.ApplyType || (Globals.ApplyType = {}));
    var ApplyType = Globals.ApplyType;
    (function (PipType) {
        PipType[PipType["state"] = 0] = "state";
        PipType[PipType['event'] = 1] = 'event';
        PipType[PipType["template"] = 2] = "template";
        PipType[PipType["stateItem"] = 3] = "stateItem";
        PipType[PipType["eventItem"] = 4] = "eventItem";
        PipType[PipType["templateItem"] = 5] = "templateItem";
        PipType[PipType["element"] = 6] = "element";
        PipType[PipType["listItem"] = 7] = "listItem";
        PipType[PipType["itemElement"] = 8] = "itemElement";
        PipType[PipType["shadowElement"] = 9] = "shadowElement";
        PipType[PipType["select"] = 10] = "select";
        PipType[PipType["router"] = 11] = "router";
        PipType[PipType["model"] = 12] = "model";
        PipType[PipType["collection"] = 13] = "collection";
        PipType[PipType["sub"] = 14] = "sub";
        PipType[PipType["list"] = 15] = "list";
        PipType[PipType["api"] = 16] = "api";
        PipType[PipType["target"] = 17] = "target";
        PipType[PipType["targetItem"] = 18] = "targetItem";
        PipType[PipType["navTree"] = 19] = "navTree";
        PipType[PipType["treeModel"] = 20] = "treeModel";
        PipType[PipType["nestCollection"] = 21] = "nestCollection";
        PipType[PipType["tree"] = 22] = "tree";
        PipType[PipType["nest"] = 23] = "nest";
        PipType[PipType["treeItem"] = 24] = "treeItem";
        PipType[PipType["leaf"] = 25] = "leaf";
    })(Globals.PipType || (Globals.PipType = {}));
    var PipType = Globals.PipType;
    (function (RegPipType) {
        RegPipType[RegPipType["element"] = 0] = "element";
        RegPipType[RegPipType["listItem"] = 1] = "listItem";
        RegPipType[RegPipType["itemElement"] = 2] = "itemElement";
        RegPipType[RegPipType["shadowElement"] = 3] = "shadowElement";
    })(Globals.RegPipType || (Globals.RegPipType = {}));
    var RegPipType = Globals.RegPipType;
    (function (PipClass) {
        PipClass[PipClass["el"] = 0] = "el";
        PipClass[PipClass["tpl"] = 1] = "tpl";
        PipClass[PipClass["state"] = 2] = "state";
        PipClass[PipClass["enable"] = 3] = "enable";
        PipClass[PipClass["select"] = 4] = "select";
        PipClass[PipClass["attr"] = 5] = "attr";
        PipClass[PipClass["list"] = 6] = "list";
        PipClass[PipClass["sub"] = 7] = "sub";
        PipClass[PipClass["target"] = 8] = "target";
        PipClass[PipClass["router"] = 9] = "router";
        PipClass[PipClass["tree"] = 10] = "tree";
        PipClass[PipClass["nav"] = 11] = "nav";
        PipClass[PipClass["api"] = 12] = "api";
    })(Globals.PipClass || (Globals.PipClass = {}));
    var PipClass = Globals.PipClass;
    (function (LinkCategory) {
        LinkCategory[LinkCategory["forbidden"] = 0] = "forbidden";
        LinkCategory[LinkCategory['default'] = 1] = 'default';
        LinkCategory[LinkCategory["complex"] = 2] = "complex";
    })(Globals.LinkCategory || (Globals.LinkCategory = {}));
    var LinkCategory = Globals.LinkCategory;
    (function (Action) {
        Action[Action["update"] = 0] = "update";
        Action[Action["create"] = 1] = "create";
        Action[Action["remove"] = 2] = "remove";
        Action[Action["insert"] = 3] = "insert";
        Action[Action['delete'] = 4] = 'delete';
    })(Globals.Action || (Globals.Action = {}));
    var Action = Globals.Action;
    (function (MessageKey) {
        MessageKey[MessageKey["value"] = 0] = "value";
        MessageKey[MessageKey["it"] = 1] = "it";
        MessageKey[MessageKey["action"] = 2] = "action";
        MessageKey[MessageKey["emit"] = 3] = "emit";
        MessageKey[MessageKey["index"] = 4] = "index";
    })(Globals.MessageKey || (Globals.MessageKey = {}));
    var MessageKey = Globals.MessageKey;
    (function (Element) {
        Element[Element["anc"] = 0] = "anc";
        Element[Element["root"] = 1] = "root";
        Element[Element["el"] = 2] = "el";
    })(Globals.Element || (Globals.Element = {}));
    var Element = Globals.Element;
    (function (AddressKey) {
        AddressKey[AddressKey["pip"] = 0] = "pip";
        AddressKey[AddressKey["anc"] = 1] = "anc";
        AddressKey[AddressKey["sel"] = 2] = "sel";
        AddressKey[AddressKey["root"] = 3] = "root";
        AddressKey[AddressKey["item"] = 4] = "item";
        AddressKey[AddressKey["el"] = 5] = "el";
        AddressKey[AddressKey["selector"] = 6] = "selector";
    })(Globals.AddressKey || (Globals.AddressKey = {}));
    var AddressKey = Globals.AddressKey;
    (function (OptionName) {
        OptionName[OptionName["root"] = 0] = "root";
        OptionName[OptionName["selector"] = 1] = "selector";
        OptionName[OptionName["idType"] = 2] = "idType";
        OptionName[OptionName["name"] = 3] = "name";
        OptionName[OptionName["attr"] = 4] = "attr";
        OptionName[OptionName["type"] = 5] = "type";
        OptionName[OptionName["method"] = 6] = "method";
        OptionName[OptionName["empty"] = 7] = "empty";
        OptionName[OptionName["filter"] = 8] = "filter";
        OptionName[OptionName["sort"] = 9] = "sort";
        OptionName[OptionName["idKey"] = 10] = "idKey";
        OptionName[OptionName["tpl"] = 11] = "tpl";
        OptionName[OptionName["children"] = 12] = "children";
        OptionName[OptionName["model"] = 13] = "model";
        OptionName[OptionName["index"] = 14] = "index";
        OptionName[OptionName["keys"] = 15] = "keys";
        OptionName[OptionName["server"] = 16] = "server";
        OptionName[OptionName["preventDefault"] = 17] = "preventDefault";
        OptionName[OptionName["delegation"] = 18] = "delegation";
        OptionName[OptionName["events"] = 19] = "events";
        OptionName[OptionName["bindFn"] = 20] = "bindFn";
        OptionName[OptionName["enable"] = 21] = "enable";
        OptionName[OptionName['default'] = 22] = 'default';
        OptionName[OptionName["value"] = 23] = "value";
        OptionName[OptionName["states"] = 24] = "states";
        OptionName[OptionName["one"] = 25] = "one";
        OptionName[OptionName["required"] = 26] = "required";
        OptionName[OptionName["reselectable"] = 27] = "reselectable";
        OptionName[OptionName["routing"] = 28] = "routing";
        OptionName[OptionName["it"] = 29] = "it";
    })(Globals.OptionName || (Globals.OptionName = {}));
    var OptionName = Globals.OptionName;
    (function (LinkOptionName) {
        LinkOptionName[LinkOptionName["pub"] = 0] = "pub";
        LinkOptionName[LinkOptionName["sub"] = 1] = "sub";
        LinkOptionName[LinkOptionName["binding"] = 2] = "binding";
        LinkOptionName[LinkOptionName["drop"] = 3] = "drop";
        LinkOptionName[LinkOptionName["pre"] = 4] = "pre";
        LinkOptionName[LinkOptionName["filter"] = 5] = "filter";
        LinkOptionName[LinkOptionName["sort"] = 6] = "sort";
        LinkOptionName[LinkOptionName["value"] = 7] = "value";
        LinkOptionName[LinkOptionName["action"] = 8] = "action";
        LinkOptionName[LinkOptionName["it"] = 9] = "it";
        LinkOptionName[LinkOptionName["variables"] = 10] = "variables";
        LinkOptionName[LinkOptionName["auto"] = 11] = "auto";
        LinkOptionName[LinkOptionName["refine"] = 12] = "refine";
    })(Globals.LinkOptionName || (Globals.LinkOptionName = {}));
    var LinkOptionName = Globals.LinkOptionName;
    (function (PipProps) {
        PipProps[PipProps["pipType"] = 0] = "pipType";
        PipProps[PipProps["pipClass"] = 1] = "pipClass";
        PipProps[PipProps["itType"] = 2] = "itType";
        PipProps[PipProps["initReg"] = 3] = "initReg";
        PipProps[PipProps["setReg"] = 4] = "setReg";
        PipProps[PipProps["values"] = 5] = "values";
        PipProps[PipProps["outActions"] = 6] = "outActions";
        PipProps[PipProps["regActions"] = 7] = "regActions";
        PipProps[PipProps["diffTest"] = 8] = "diffTest";
        PipProps[PipProps["emptyInput"] = 9] = "emptyInput";
        PipProps[PipProps["pipFn"] = 10] = "pipFn";
        PipProps[PipProps["switchFn"] = 11] = "switchFn";
        PipProps[PipProps["defineItemId"] = 12] = "defineItemId";
        PipProps[PipProps["correctInput"] = 13] = "correctInput";
        PipProps[PipProps["server"] = 14] = "server";
        PipProps[PipProps["emitTest"] = 15] = "emitTest";
        PipProps[PipProps["interpret"] = 16] = "interpret";
        PipProps[PipProps["publicFn"] = 17] = "publicFn";
    })(Globals.PipProps || (Globals.PipProps = {}));
    var PipProps = Globals.PipProps;
    (function (OptionValue) {
        OptionValue[OptionValue["append"] = 0] = "append";
        OptionValue[OptionValue["prepend"] = 1] = "prepend";
        OptionValue[OptionValue["html"] = 2] = "html";
        OptionValue[OptionValue["unAppend"] = 3] = "unAppend";
        OptionValue[OptionValue["unPrepend"] = 4] = "unPrepend";
        OptionValue[OptionValue["wrap"] = 5] = "wrap";
        OptionValue[OptionValue["remove"] = 6] = "remove";
        OptionValue[OptionValue["insertBefore"] = 7] = "insertBefore";
        OptionValue[OptionValue["insertAfter"] = 8] = "insertAfter";
    })(Globals.OptionValue || (Globals.OptionValue = {}));
    var OptionValue = Globals.OptionValue;
    Globals.conversionTable = {
        'class': ApplyType[ApplyType.cl],
        'display': ApplyType[ApplyType.css],
        'autofocus': ApplyType[ApplyType.prop],
        'checked': ApplyType[ApplyType.prop],
        'alt': ApplyType[ApplyType.attr]
    };
    Globals.navTree;
    (function (Direction) {
        Direction[Direction["ASC"] = 0] = "ASC";
        Direction[Direction["DESC"] = 1] = "DESC";
    })(Globals.Direction || (Globals.Direction = {}));
    var Direction = Globals.Direction;
})(Globals || (Globals = {}));
var PC = Globals.PipClass;

var Utils;
(function (Utils) {
    function trim(str) {
        return str.replace(/^\s+|\s+$/g, '');
    }
    Utils.trim = trim;
    function caseUp(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }
    Utils.caseUp = caseUp;
    function caseDown(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
    }
    Utils.caseDown = caseDown;
    function mergeTermsCamelCase(terms) {
        return caseDown(R.join('', R.map(caseUp, R.sort(function (a, b) { return a < b ? -1 : a === b ? 0 : 1; }, R.filter(function (a) { return a !== ''; }, terms.split(' '))))));
    }
    Utils.mergeTermsCamelCase = mergeTermsCamelCase;
    function quicksort(items, left, right) {
        function swap(items, firstIndex, secondIndex) {
            var temp = items[firstIndex];
            items[firstIndex] = items[secondIndex];
            items[secondIndex] = temp;
        }
        function partition(items, left, right) {
            var pivot = items[Math.floor((right + left) / 2)], i = left, j = right;
            while (i <= j) {
                while (items[i] < pivot) {
                    i++;
                }
                while (items[j] > pivot) {
                    j--;
                }
                if (i <= j) {
                    swap(items, i, j);
                    i++;
                    j--;
                }
            }
            return i;
        }
        var index;
        if (items.length > 1) {
            index = partition(items, left, right);
            if (left < index - 1) {
                this.quicksort(items, left, index - 1);
            }
            if (index < right) {
                this.quicksort(items, index, right);
            }
        }
        return items;
    }
    Utils.quicksort = quicksort;
    function insert(idx, value, store) {
        store.splice(idx, 0, value);
    }
    Utils.insert = insert;
    function remove(idx, len, store) {
        store.splice(idx, len);
    }
    Utils.remove = remove;
    function merge(target, seed) {
        var props = R.keys(seed);
        var idx = -1, len = props.length;
        while (++idx < len) {
            target[props[idx]] = seed[props[idx]];
        }
    }
    Utils.merge = merge;
})(Utils || (Utils = {}));

var DefaultValues;
(function (DefaultValues) {
    var G = Globals;
    DefaultValues.STATES_TARGET = [{
            name: G.NO_TARGET,
            attr: 'display',
            value: 'none'
        }, {
            name: G.IS_TARGET,
            attr: 'display',
            value: ''
        }];
    DefaultValues.STATES_SELECT = [{
            name: G.IS_UNSELECTED,
            attr: 'class',
            value: G.IS_UNSELECTED
        }, {
            name: G.IS_SELECTED,
            attr: 'class',
            value: G.IS_SELECTED
        }];
    DefaultValues.serverAddress = "http://localhost:9090/";
    DefaultValues.serverIndexAttr = '_id';
    DefaultValues.MERGETOKEN = '%%';
    DefaultValues.DEFAULTEVENTS = 'click touchstart';
    DefaultValues.IT = '__it';
    DefaultValues.POS = '__pos';
    DefaultValues.IS_TARGET = 'is-target';
    DefaultValues.NO_TARGET = 'no-target';
    DefaultValues.IS_SELECTED = 'is-selected';
    DefaultValues.IS_UNSELECTED = 'is-unselected';
    DefaultValues.ENABLED = 'is-open';
    DefaultValues.DISABLED = 'is-closed';
    DefaultValues.TRUE = true;
    DefaultValues.FALSE = false;
})(DefaultValues || (DefaultValues = {}));

var Monads;
(function (Monads) {
    var IO = (function () {
        function IO(fn) {
            this.fn = fn;
        }
        IO.prototype.chain = function (f) {
            var io = this;
            return new IO(function () {
                return f(io.fn()).fn();
            });
        };
        IO.prototype.map = function (f) {
            var io = this;
            return new IO(R.compose(f, io.fn));
        };
        IO.prototype.ap = function (m) {
            return this.chain(function (f) {
                return m.map(f);
            });
        };
        IO.prototype.runIO = function () {
            return this.fn.apply(this, arguments);
        };
        IO.prototype.of = function (x) {
            return new IO(function () {
                return x;
            });
        };
        IO.prototype.get = function () {
            return this.fn();
        };
        IO.prototype.equals = function (that) {
            return IO.runIO(this).is(IO.runIO(that));
        };
        IO.runIO = function (io) {
            return io.runIO.apply(io, [].slice.call(arguments, 1));
        };
        IO.of = IO.prototype.of;
        return IO;
    })();
    Monads.IO = IO;
    var Future = (function () {
        function Future(fn) {
            this.fork = fn;
        }
        Future.prototype.map = function (f) {
            return this.chain(function (a) {
                return Future.of(f(a));
            });
        };
        Future.prototype.ap = function (m) {
            return this.chain(function (f) {
                return m.map(f);
            });
        };
        Future.prototype.of = function (x) {
            return new Future(function (_, resolve) {
                return resolve(x);
            });
        };
        Future.prototype.chain = function (f) {
            return new Future(function (reject, resolve) {
                return this.fork(function (a) { return reject(a); }, function (b) { return f(b).fork(reject, resolve); });
            }.bind(this));
        };
        Future.prototype.equals = function (that) {
            void that;
            return true;
        };
        Future.of = Future.prototype.of;
        return Future;
    })();
    Monads.Future = Future;
})(Monads || (Monads = {}));

var API;
(function (API) {
    function addPipType(name) {
        var pt = Globals.PipType;
        var nr = R.keys(Globals.PipType).length / 2;
        pt[pt[name] = nr] = name;
    }
    API.addPipType = addPipType;
})(API || (API = {}));

var LinkingPips;
(function (LinkingPips) {
    var G = Globals;
    var D = DefaultValues;
    var PT = G.PipType;
    var ACT = G.Action;
    var MK = G.MessageKey;
    var ON = G.OptionName;
    var AK = G.AddressKey;
    var LO = G.LinkOptionName;
    var App = (function () {
        function App(domString, nodes, pips, links, nameSpace, externals) {
            if (nameSpace === void 0) { nameSpace = 'pips'; }
            var internalApp = new InternalApp(domString, nodes, pips, links, nameSpace, externals);
            return {
                get: internalApp.storage.get,
                getAll: internalApp.storage.getAll
            };
        }
        return App;
    })();
    LinkingPips.App = App;
    var InternalApp = (function () {
        function InternalApp(domString, nodes, pips, links, nameSpace, externals) {
            var _this = this;
            if (nameSpace === void 0) { nameSpace = 'pips'; }
            this.regAddressBook = {};
            this.navTree = [];
            this.navLinks = [];
            this.navTreeSpec = {
                options: { type: PT[PT.navTree] },
                addresses: { pip: 'navTree' }
            };
            this.routerRoots = [];
            this.nameSpace = nameSpace;
            this.domString = domString;
            this.storage = Store.Storage();
            this.pips = pips;
            this.links = links;
            this.nodes = R.clone(nodes);
            this.analyser = Tree.Analyser();
            if (externals)
                this.addExternals(externals);
            this.appInit = true;
            this.init(this.domString);
            this.appInit = false;
            Pips.create({
                type: PT[PT.router],
                rules: 'path',
                initValue: 'index',
                error: '404'
            }, { pip: 'router' }, this.storage);
            this.addNavTree();
            R.forEach(function (link) { return _this.addLink(link); }, this.navLinks);
            this.addLink({
                pub: PT[PT.navTree],
                sub: PT[PT.router],
                pre: function (i) { return R.filter(function (inp) {
                    return inp[MK[MK.action]] === ACT[ACT.insert] || inp[MK[MK.action]] === ACT[ACT.remove];
                }, i); }
            });
        }
        InternalApp.prototype.addExternals = function (externals) {
            var app = this;
            externals = R.is(Array, externals) ? externals : [externals];
            R.forEach(function (extern) {
                API.addPipType(extern.name);
                if (extern.ref) {
                    Pip.Options.defaults[extern.name] = Pip.Options.defaults[extern.ref];
                    if (typeof extern.options === 'function') {
                        Pip.Props.def[extern.name] = function (opts, addr, storage) {
                            return R.merge(Pip.Props.def[extern.ref](opts, addr, storage), extern.options.call(R.merge(Pip, { getPip: app.storage.get }), opts, addr, storage));
                        };
                    }
                    else {
                        Pip.Props.def[extern.name] = function (opts, addr, storage) {
                            return Pip.Props.def[extern.ref](opts, addr, storage);
                        };
                    }
                }
                else {
                    Pip.Props.def[extern.name] = function (opts, addr, storage) {
                        return extern.options.call(R.merge(Pip, { getPip: app.storage.get }), opts, addr, storage);
                    };
                }
            }, externals);
        };
        InternalApp.prototype.loopWithSequenceControl = function (orgArray, sequenceTest, action) {
            var arrayLengthStack = [], orphanLoop = false, array = R.clone(orgArray);
            while (array.length > 0 && !orphanLoop) {
                arrayLengthStack.push(array.length);
                var element = array.shift();
                var testResult = sequenceTest.call(this, element);
                if (testResult.test) {
                    action.call(this, testResult.arg);
                }
                else {
                    var stackLength = arrayLengthStack.length;
                    var lastLength = arrayLengthStack[stackLength - 1], repetitionOfNodeLength = 0, endOfRepetition = false;
                    while (!endOfRepetition) {
                        if (stackLength > 1) {
                            var nthLastLength = arrayLengthStack[stackLength - (2 + repetitionOfNodeLength)];
                            if (nthLastLength !== lastLength) {
                                endOfRepetition = true;
                            }
                            else {
                                repetitionOfNodeLength++;
                            }
                        }
                        else {
                            repetitionOfNodeLength++;
                            endOfRepetition = true;
                        }
                    }
                    if (repetitionOfNodeLength > array.length + 1) {
                        orphanLoop = true;
                        throw new Error('node options have no match within html or linkoptions have no match with defined pips, within element options: ' + array);
                    }
                    else {
                        array.push(element);
                    }
                }
            }
            return array;
        };
        InternalApp.prototype.linkSequenceTest = function (linkOptions) {
            var _this = this;
            var pipsThatNeedToExist = [linkOptions[LO[LO.pub]], linkOptions[LO[LO.sub]]];
            if (linkOptions[LO[LO.drop]]) {
                pipsThatNeedToExist = pipsThatNeedToExist.concat(linkOptions[LO[LO.drop]]);
            }
            var ns = this.nameSpace;
            var atLeastOnePipDoesntExist = R.reduce(function (acc, pip) {
                return acc || !_this.storage.exists(pip);
            }, false, pipsThatNeedToExist);
            return {
                test: !atLeastOnePipDoesntExist,
                arg: linkOptions
            };
        };
        InternalApp.prototype.pipSequenceTest = function (pipOptions) {
            var existRegPip = Pip.RegPip.assure.call(this, pipOptions, this.storage);
            return {
                test: existRegPip,
                arg: existRegPip ? Pip.Spec.define(pipOptions, this.regAddressBook) : null
            };
        };
        InternalApp.prototype.init = function (domString) {
            var tree = this.analyser.extract(domString);
            var treeSpec = {
                navTree: this.navTree,
                regAddressBook: this.regAddressBook
            };
            Tree.Flatten.flattenTree.call(this, [tree]);
            var nodesClone = R.clone(this.nodes);
            this.loopWithSequenceControl(nodesClone, this.pipSequenceTest, this.initNode);
            this.loopWithSequenceControl(this.pips, this.pipSequenceTest, this.addPip);
            this.loopWithSequenceControl(this.links, this.linkSequenceTest, this.addLink);
        };
        InternalApp.prototype.addPip = function (pipSpec, replaceNavTree) {
            var pipType = pipSpec.options[ON[ON.type]];
            switch (pipType) {
                case PT[PT.select]:
                    Pips.create(pipSpec.options, pipSpec.addresses, this.storage);
                    this.addStateItem(pipSpec);
                    break;
                case PT[PT.target]:
                case PT[PT.targetItem]:
                    this.addTarget(pipSpec, replaceNavTree);
                    break;
                case PT[PT.sub]:
                case PT[PT.list]:
                    this.initNode(pipSpec);
                    break;
                case PT[PT.navTree]:
                    this.addNavTree();
                    break;
                default:
                    Pips.create(pipSpec.options, pipSpec.addresses, this.storage);
            }
        };
        InternalApp.prototype.removePip = function (pipId, replaceNavTree) {
            var pip = this.storage.get(pipId);
            var pipType = pip.getType();
            if (pipType === PT[PT.select] || pipType === PT[PT.targetItem]) {
                var statePipId;
                var links = pip.getLinks();
                R.forEach(function (link) {
                    if (link[LO[LO.auto]]) {
                        var subPipId = link[LO[LO.sub]];
                        Pips.remove(subPipId, this.nameSpace);
                    }
                }, links);
            }
            var linkSources = pip.getLinkSources();
            if (linkSources) {
                R.forEach(function (pubPibId) {
                    var pubPip = this.storage.get(pubPibId);
                    pubPip.removeLink(pipId);
                }, linkSources);
            }
            var bindingSources = pip.getBindingSources();
            if (bindingSources) {
                R.forEach(function (pubPibId) {
                    var pubPip = this.storage.get(pubPibId);
                    pubPip.removeBinding(pipId);
                }, bindingSources);
            }
            if (this.virtualDOM && R.contains(pipType, [PT[PT.element], PT[PT.listItem], PT[PT.itemElement], PT[PT.shadowElement]])) {
                this.virtualDOM.react({
                    it: pipId,
                    action: ACT[ACT.remove]
                });
            }
            Pips.remove(pipId, this.storage);
            if (replaceNavTree || (replaceNavTree === void 0 && (pipType === PT[PT.target] || pipType === PT[PT.targetItem]))) {
                var targetIndex = R.findIndex(R.propEq('target', pipId), this.routerRoots);
                if (targetIndex) {
                    Utils.remove(targetIndex, 1, this.routerRoots);
                }
                if (!this.appInit && replaceNavTree) {
                    this.replacePip({ type: PT[PT.navTree] }, { pip: 'navTree' });
                }
            }
        };
        InternalApp.prototype.movePip = function (options, newAddress, oldAddress) {
            var _this = this;
            var pipType = options[ON[ON.type]], replaceNavTree;
            if (pipType === PT[PT.targetItem] || pipType === PT[PT.target]) {
                if (options[ON[ON.routing]] && !R.find(R.propEq('target', newAddress[AK[AK.pip]]), this.routerRoots)) {
                    replaceNavTree = true;
                }
                else if (oldAddress) {
                    if (oldAddress[AK[AK.anc]] !== newAddress[AK[AK.anc]]) {
                        replaceNavTree = true;
                    }
                    else {
                        replaceNavTree = false;
                    }
                }
            }
            oldAddress = oldAddress ? oldAddress : newAddress;
            var oldPipId = oldAddress[AK[AK.pip]];
            var oldPip = this.storage.get(oldPipId);
            var oldLinks = oldPip.getLinks();
            var oldLinkSources = oldPip.getLinkSources();
            var oldSourceLinks = oldLinkSources
                ? R.map(function (pubPipId) {
                    var pubPip = _this.storage.get(pubPipId);
                    return {
                        pub: pubPip,
                        link: pubPip.getLinks(oldPipId)
                    };
                }, oldLinkSources)
                : [];
            var oldBindingSources = oldPip.getBindingSources();
            var oldSourceBindings = oldBindingSources
                ? R.map(function (pubPipId) {
                    var pubPip = this.storage.get(pubPipId);
                    return {
                        pub: pubPip,
                        binding: pubPip.getBindings(oldPipId)
                    };
                }, oldBindingSources)
                : [];
            var oldPipBindings;
            if (pipType === PT[PT.event] || pipType === PT[PT.eventItem]) {
                oldPipBindings = oldPip.getBindings();
            }
            if (oldAddress[AK[AK.anc]]) {
                this.removePubSubLink(oldAddress[AK[AK.anc]], oldPipId);
            }
            this.removePip(oldPipId, replaceNavTree);
            this.addPip({ options: options, addresses: newAddress }, replaceNavTree);
            var newPipId = newAddress[AK[AK.pip]], newPip = this.storage.get(newPipId);
            if (oldLinks) {
                newPip.addLinks(oldLinks, this.nameSpace);
                var init = newPip.getInit();
                var links = newPip.getLinks();
                if (init) {
                    if (!R.is(Array, init) || init.length !== 0) {
                        R.forEach(function (link) {
                            var subPip = link.subPip;
                            subPip.react(init);
                        }, oldLinks);
                    }
                }
            }
            if (oldPipBindings) {
                newPip.addBinding(oldPipBindings, this.nameSpace);
            }
            R.forEach(function (oSL) {
                var pubPip = oSL.pub;
                var newLink = {
                    sub: newPipId,
                    subPip: newPip,
                    fn: oSL.link.fn
                };
                pubPip.addLink(newLink);
            }, oldSourceLinks);
            R.forEach(function (oSB) {
                var pubPip = oSB.pub;
                var newBinding = {
                    sub: newPipId,
                    subPip: newPip,
                    fn: oSB.binding.fn
                };
                pubPip.addBinding(newBinding);
            }, oldSourceBindings);
        };
        InternalApp.prototype.replacePip = function (options, address) {
            this.movePip(options, address);
        };
        InternalApp.prototype.addLink = function (linkOptions) {
            Links.create(linkOptions, this.storage);
        };
        InternalApp.prototype.removeLink = function (linkOptions) {
            var pubPipId = linkOptions.pub, subPipId = linkOptions.sub, pubPip = this.storage.get(pubPipId);
            if (linkOptions.binding) {
                pubPip.removeBinding(subPipId);
            }
            else {
                pubPip.removeLink(subPipId);
            }
        };
        InternalApp.prototype.replaceLink = function (oldLinkOptions, newLinkOptions) {
            var oldSubPipId = oldLinkOptions.sub, oldPubPipId = oldLinkOptions.pub, oldPubPip = this.storage.get(oldPubPipId);
            if (oldLinkOptions.binding) {
                oldPubPip.removeBinding(oldSubPipId);
            }
            else {
                oldPubPip.removeLink(oldSubPipId);
            }
            this.addLink(newLinkOptions);
        };
        InternalApp.prototype.removePubSubLink = function (pubId, subId) {
            var pubPip = this.storage.get(pubId);
            pubPip.removeLink(subId);
        };
        InternalApp.prototype.removePubSubBinding = function (pubId, subId) {
            var pubPip = this.storage.get(pubId);
            pubPip.removeBinding(subId);
        };
        InternalApp.prototype.findListItemTagName = function (ancestorId) {
            var rootId = this.storage.exists(ancestorId + '.list')
                ? ancestorId + '.list'
                : ancestorId;
            var containerSelector;
            var listItemNavModel = R.find(function (navModel) {
                return R.propEq('type', PT[PT.listItem], navModel) && R.propEq('parent', rootId, navModel);
            }, this.navTree);
            var listItemPipId = listItemNavModel.id;
            return this.regAddressBook[listItemPipId].sel;
        };
        InternalApp.prototype.findItemElementTagName = function (selector) {
            var itemElementNavModel = R.find(function (navModel) {
                return R.propEq('type', PT[PT.itemElement], navModel) && R.propEq('parent', selector, navModel);
            }, this.navTree);
            var itemElementPipId = itemElementNavModel.id;
            return this.regAddressBook[itemElementPipId].sel;
        };
        InternalApp.prototype.addStateItem = function (pipSpec, containerTag) {
            var pipType = pipSpec.options[ON[ON.type]];
            var ancestorId = pipSpec.addresses[AK[AK.anc]];
            var defaultSelectStates = pipType === PT[PT.select] ? D.STATES_SELECT : D.STATES_TARGET;
            pipSpec.options[ON[ON.states]] = pipSpec.options[ON[ON.states]] || defaultSelectStates;
            var selectStates = Pip.Spec.defineSelectStates(pipSpec.options);
            containerTag = containerTag || this.findListItemTagName(ancestorId);
            var selector = ancestorId + '>' + containerTag;
            var selectorIsDefined;
            if (!pipSpec.options[ON[ON.it]] || containerTag === pipSpec.options[ON[ON.it]]) {
                selectorIsDefined = true;
            }
            while (!selectorIsDefined) {
                var selectorTag = this.findItemElementTagName(selector);
                if (selectorTag) {
                    selector = selector + '>' + selectorTag;
                    if (selectorTag === pipSpec.options[ON[ON.it]]) {
                        selectorIsDefined = true;
                    }
                }
                else {
                    throw new Error('cannot find tag for auto-stateItem with tagName: ' + pipSpec.options[ON[ON.it]]);
                }
            }
            var stateItemOpts = {
                type: 'stateItem',
                selector: selector,
                default: pipSpec.options[ON[ON.default]] || selectStates.unSelected,
                states: pipSpec.options[ON[ON.states]]
            };
            var stateItemSpec = Pip.Spec.define.call(this, stateItemOpts);
            Pips.create(stateItemOpts, stateItemSpec.addresses, this.storage);
            this.addLink({
                pub: pipSpec.addresses[AK[AK.pip]],
                sub: stateItemSpec.addresses[AK[AK.pip]],
                auto: true,
                value: function (i) {
                    return (i[MK[MK.value]] === true) ? selectStates.selected : selectStates.unSelected;
                }
            });
            this.addLink({
                pub: stateItemSpec.addresses[AK[AK.pip]],
                sub: pipSpec.addresses[AK[AK.pip]],
                auto: true,
                value: function (i) {
                    return i[MK[MK.value]] === selectStates.selected;
                }
            });
        };
        InternalApp.prototype.addTarget = function (targetSpec, replaceNavTree) {
            var _this = this;
            var itType = targetSpec.options[ON[ON.type]] === PT[PT.targetItem];
            var ancestorId = targetSpec.addresses[AK[AK.anc]];
            var navLinks = [];
            if (itType) {
                Pips.create(targetSpec.options, targetSpec.addresses, this.storage);
                var containerTag = this.findListItemTagName(ancestorId);
                var containerSelector = ancestorId + '>' + containerTag;
                var dynamicList = this.storage.exists(ancestorId + '.list');
                if (!dynamicList) {
                    var listItemNode = R.find(function (n) { return n[ON[ON.type]] === PT[PT.listItem] && n[ON[ON.selector]] === containerSelector; }, this.nodes);
                    if (!listItemNode) {
                        var listItemOpts = {
                            type: PT[PT.listItem],
                            selector: containerSelector,
                            idType: 'id'
                        };
                        var listItemAddr = {
                            anc: ancestorId,
                            pip: containerSelector,
                            sel: containerTag
                        };
                        this.replacePip(listItemOpts, listItemAddr);
                    }
                }
                targetSpec.options[ON[ON.it]] = containerTag;
                this.addStateItem(targetSpec);
                if (targetSpec.options[ON[ON.routing]] !== undefined && targetSpec.options[ON[ON.routing]] !== false) {
                    navLinks = navLinks.concat([
                        {
                            pub: targetSpec.addresses[AK[AK.pip]],
                            sub: PT[PT.router],
                            value: function (i) {
                                return {
                                    active: i[MK[MK.value]],
                                    anc: ancestorId
                                };
                            }
                        }, {
                            pub: PT[PT.router],
                            sub: targetSpec.addresses[AK[AK.pip]],
                            pre: function (i) { return R.reduce(function (acc, inp) {
                                if (inp[MK[MK.action]] === ACT[ACT.update] && inp[MK[MK.value]].anc && inp[MK[MK.value]].anc === ancestorId) {
                                    acc.push({
                                        it: inp[MK[MK.it]],
                                        action: ACT[ACT.update],
                                        value: inp[MK[MK.value]].active
                                    });
                                }
                                return acc;
                            }, [], i); }
                        }, {
                            pub: containerSelector,
                            sub: PT[PT.navTree],
                            value: function (i) {
                                return { anc: ancestorId };
                            }
                        }
                    ]);
                    this.routerRoots.push({ target: containerSelector, anc: ancestorId });
                }
            }
            else {
                if (!targetSpec.options[ON[ON.states]]) {
                    targetSpec.options[ON[ON.default]];
                    targetSpec.options[ON[ON.states]] = D.STATES_TARGET;
                }
                Pips.create(targetSpec.options, targetSpec.addresses, this.storage);
                if (targetSpec.options[ON[ON.routing]] !== undefined && targetSpec.options[ON[ON.routing]] !== false) {
                    navLinks = navLinks.concat([
                        {
                            pub: targetSpec.addresses.pip,
                            sub: PT[PT.router],
                            pre: function (i) { return [{
                                    it: ancestorId,
                                    action: ACT[ACT.update],
                                    value: {
                                        active: i[MK[MK.value]] === G.IS_TARGET
                                    }
                                }]; }
                        }, {
                            pub: PT[PT.router],
                            sub: targetSpec.addresses.pip,
                            pre: function (i) { return i[MK[MK.action]] === ACT[ACT.update] && i[MK[MK.it]] === ancestorId
                                ? {
                                    action: ACT[ACT.update],
                                    value: i[MK[MK.value]].active
                                }
                                : void 0; }
                        }, {
                            pub: ancestorId,
                            sub: 'navTree',
                            pre: function (i) { return [{
                                    action: i[MK[MK.action]],
                                    it: ancestorId,
                                    value: {}
                                }]; }
                        }
                    ]);
                    this.routerRoots.push({ target: ancestorId });
                }
            }
            if (this.appInit) {
                this.navLinks = this.navLinks.concat(navLinks);
            }
            else {
                if (this.storage.get('navTree')) {
                    this.replacePip(this.navTreeSpec.options, this.navTreeSpec.addresses);
                    R.forEach(function (navLink) { return _this.addLink(navLink); }, navLinks);
                }
            }
        };
        InternalApp.prototype.composeNavTreeOptions = function () {
            //uitgangspunt: waar nodig, zijn er shadowelements?
            //en dat shadowElement wordt weliswaar aangeduid met bijv #main>div(0) maar heeft 100% zeker id bijv #page1
            //anders past targetPip niet!
            //TODO nog oplossing nodig voor dynamisch geneste lijsten met targetItempips: er worden live geen repPips meer toegevoegd
            var _this = this;
            var potentialTargets = R.pluck('target', this.routerRoots);
            var navTreeOptions = {};
            R.forEach(function (routerRoot) {
                var parentTarget, lookupId = routerRoot.anc
                    ? routerRoot.anc
                    : routerRoot.target, testId = lookupId;
                while (!parentTarget) {
                    var navModel = R.find(function (nm) { return R.propEq('id', testId, nm); }, _this.navTree);
                    var parentId = navModel.parent;
                    if (!parentId) {
                        parentTarget = 'body';
                    }
                    else if (R.contains(parentId, potentialTargets)) {
                        var routerRootModel = R.find(function (rrm) { return R.propEq('target', parentId, rrm); }, _this.routerRoots);
                        parentTarget = routerRootModel.anc
                            ? testId
                            : parentId;
                    }
                    else {
                        testId = parentId;
                    }
                }
                navTreeOptions[lookupId] = parentTarget;
            }, this.routerRoots);
            return navTreeOptions;
        };
        InternalApp.prototype.addNavTree = function () {
            Pips.create({
                type: PT[PT.navTree],
                navTree: this.composeNavTreeOptions()
            }, { pip: 'navTree' }, this.storage);
        };
        InternalApp.prototype.initNode = function (nodeSpec) {
            var nodePipId = nodeSpec.addresses[AK[AK.pip]], nodeRoot = nodeSpec.addresses[AK[AK.anc]];
            if (this.storage.exists(nodePipId)) {
                this.replacePip(nodeSpec.options, nodeSpec.addresses);
            }
            else {
                Pips.create(nodeSpec.options, nodeSpec.addresses, this.storage);
                this.addNode(nodeSpec.options, nodeSpec.addresses);
            }
        };
        InternalApp.prototype.addNode = function (options, addresses) {
            var rootId = addresses[AK[AK.anc]], nodeId = addresses[AK[AK.pip]], isList = options[ON[ON.type]] === PT[PT.list];
            if (options[ON[ON.type]] === PT[PT.tree] || options[ON[ON.type]] === PT[PT.nest]) {
                var listItemOpts = {
                    type: PT[PT.listItem],
                    selector: options[ON[ON.selector]] + '_*'
                };
                var listItemAddr = {
                    anc: addresses[AK[AK.pip]],
                    pip: options[ON[ON.selector]] + '_*'
                };
                this.addPip({ options: listItemOpts, addresses: listItemAddr });
            }
            else {
                var nodeTree = this.analyser.extract(options[ON[ON.tpl]], rootId, isList);
                Tree.Flatten.flattenTree.call(this, nodeTree, nodeId, rootId);
            }
        };
        return InternalApp;
    })();
})(LinkingPips || (LinkingPips = {}));

var Links;
(function (Links) {
    var G = Globals;
    var PT = G.PipType;
    var LO = G.LinkOptionName;
    var MK = G.MessageKey;
    var ACT = G.Action;
    var validActions = [ACT[ACT.create], ACT[ACT.update], ACT[ACT.delete], ACT[ACT.insert], ACT[ACT.remove]];
    function defineFilterMessages(listPip, newFilteredValues) {
        var current = listPip.get();
        var filteredItems = R.pluck(G.IT, newFilteredValues);
        var united = R.union(filteredItems, current);
        var filteredMessages = [];
        R.forEach(function (itId) {
            var filteredMessage;
            if (R.contains(itId, filteredItems)) {
                var message = R.find(function (f) { return f[G.IT] === itId; }, newFilteredValues);
                message[MK[MK.it]] = message[G.IT];
                var itemId = listPip.defineItemId(message, current);
                if (!R.contains(itemId, current)) {
                    filteredMessage = {};
                    filteredMessage[MK[MK.it]] = itId;
                    filteredMessage[MK[MK.action]] = ACT[ACT.create];
                    var keys = R.keys(message);
                    if (keys.length > 0) {
                        filteredMessage[MK[MK.value]] = {};
                        R.forEach(function (key) {
                            if (!R.contains(key, [G.IT, MK[MK.it]])) {
                                filteredMessage[MK[MK.value]][key] = message[key];
                            }
                        }, keys);
                    }
                }
            }
            else if (R.contains(itId, current)) {
                filteredMessage = {};
                filteredMessage[MK[MK.action]] = ACT[ACT.delete];
                filteredMessage[MK[MK.it]] = itId;
            }
            if (filteredMessage) {
                filteredMessages.push(filteredMessage);
            }
        }, united);
        return filteredMessages;
    }
    function filter(test, collectionPip, listPip) {
        var _this = this;
        var collection = collectionPip.get();
        var filteredValues = R.filter(function (inp) { return test.call(_this, inp); }, collection);
        collectionPip.resend();
        return defineFilterMessages(listPip, filteredValues);
    }
    function callPre(linkIn, opts, drop, vars, storage) {
        if (!opts[LO[LO.pre]] && !opts[LO[LO.filter]] && !opts[LO[LO.sort]])
            return linkIn;
        if (opts[LO[LO.pre]]) {
            if (R.is(Function, opts[LO[LO.pre]])) {
                var context = R.merge(getVariables(vars, storage), getDroppings(drop, storage));
                return (opts[LO[LO.pre]].call(context, linkIn));
            }
            else {
                throw new Error('Pre must be a function');
            }
        }
        if (opts[LO[LO.filter]] && linkIn[0]) {
            if (linkIn[0][MK[MK.emit]] === undefined || linkIn[0][MK[MK.emit]] === true) {
                var context = R.merge(getVariables(vars, storage), getDroppings(drop, storage));
                if (R.is(Function, opts[LO[LO.filter]])) {
                    var testFunction = opts[LO[LO.filter]];
                    var collectionPip = storage.get(opts[LO[LO.pub]]);
                    var listPip = storage.get(opts[LO[LO.sub]]);
                    return filter.call(context, testFunction, collectionPip, listPip);
                }
                else if (R.is(Array, opts[LO[LO.filter]])) {
                    var testFunction = opts[LO[LO.filter]][0];
                    var collectionPip = opts[LO[LO.filter]][1] ? storage.get(opts[LO[LO.filter]][1]) : storage.get(opts[LO[LO.pub]]);
                    var listPip = storage.get(opts[LO[LO.sub]]);
                    return filter.call(context, testFunction, collectionPip, listPip);
                }
                else {
                    throw new Error('filterOptions have not the correct syntax');
                }
            }
        }
        if (opts[LO[LO.sort]]) {
            throw new Error('sortOptions for links are not yet programmed');
        }
    }
    function callParameter(parameter, linkIn, opts, drop, vars, storage) {
        if (!opts[LO[LO[parameter]]])
            return linkIn[parameter];
        if (R.is(Function, opts[LO[LO[parameter]]])) {
            var context = R.merge(getVariables(vars, storage), getDroppings(drop, storage));
            return opts[LO[LO[parameter]]].call(context, linkIn);
        }
        else {
            return opts[parameter];
        }
    }
    function expand(opts, storage) {
        var drop = opts[LO[LO.drop]];
        if (!opts[LO[LO.binding]] && !opts[LO[LO.pre]] && !opts[LO[LO.filter]] && !opts[LO[LO.sort]])
            throw new Error("for expand either pre, filter or sort should be defined");
        return function (linkIn) {
            var vars = R.clone(opts[LO[LO.variables]]);
            var preResult = callPre(linkIn, opts, drop, vars, storage);
            if (preResult) {
                var result = [];
                var preResultArray = (R.is(Array, preResult) ? preResult : [preResult]);
                R.forEach(function (preRes) {
                    var res = {};
                    res[MK[MK.value]] = callParameter(LO[LO.value], preRes, opts, drop, vars, storage);
                    res[MK[MK.action]] = callParameter(LO[LO.action], preRes, opts, drop, vars, storage);
                    res[MK[MK.it]] = callParameter(LO[LO.it], preRes, opts, drop, vars, storage);
                    result.push(res);
                }, preResultArray);
                return check(result);
            }
        };
    }
    function mapOne(opts, storage) {
        var drop = opts[LO[LO.drop]];
        return function (linkIn) {
            var vars = R.clone(opts[LO[LO.variables]]);
            var preResult = callPre(linkIn, opts, drop, vars, storage);
            if (preResult) {
                var result = {};
                result[MK[MK.value]] = callParameter(LO[LO.value], preResult, opts, drop, vars, storage);
                result[MK[MK.action]] = callParameter(LO[LO.action], preResult, opts, drop, vars, storage);
                result[MK[MK.it]] = callParameter(LO[LO.it], preResult, opts, drop, vars, storage);
                return check(result);
            }
        };
    }
    function map(opts, storage) {
        var drop = opts[LO[LO.drop]];
        return function (linkIn) {
            var vars = R.clone(opts[LO[LO.variables]]);
            var preResult = callPre(linkIn, opts, drop, vars, storage);
            if (preResult && preResult.length > 0) {
                var result = R.map(function (l) {
                    var r = {};
                    r[MK[MK.value]] = callParameter(LO[LO.value], l, opts, drop, vars, storage);
                    r[MK[MK.action]] = callParameter(LO[LO.action], l, opts, drop, vars, storage);
                    r[MK[MK.it]] = callParameter(LO[LO.it], l, opts, drop, vars, storage);
                    return r;
                }, preResult);
                return check(result);
            }
        };
    }
    function valueExists(message) {
        if (message[MK[MK.value]] !== void 0)
            return message;
        else if (message[MK[MK.action]] === ACT[ACT.remove] || message[MK[MK.action]] === ACT[ACT.delete]) {
            return message;
        }
        else
            throw new TypeError('`value` of message doesn\'t exist');
    }
    function actionExists(message) {
        if (message[MK[MK.action]] !== void 0 && R.contains(message[MK[MK.action]], validActions))
            return message;
        else
            throw new TypeError('`action` of message doesn\'t exist');
    }
    function itExists(message) {
        if (message[MK[MK.it]] !== '')
            return message;
        else if (message[MK[MK.action]] === ACT[ACT.remove] || message[MK[MK.action]] === ACT[ACT.delete]) {
            return message;
        }
        else
            throw new TypeError('`it` of message doesn\'t exist');
    }
    function check(message) {
        if (message instanceof Array) {
            var exists_1 = R.compose(valueExists, actionExists, itExists);
            return R.map(exists_1, message);
        }
        var exists = R.compose(valueExists, actionExists);
        return exists(message);
    }
    function getDroppings(drop, storage) {
        drop = drop || [];
        var result = {};
        R.forEach(function (name) { result[name] = storage.get(name); }, drop);
        return result;
    }
    function getVariables(variables, storage) {
        variables = variables || {};
        return R.mapObj(function (value) {
            return R.is(Function, value) ? value.call(storage) : value;
        }, variables);
    }
    function complexLink(opts, storage, pubType, subType) {
        var pubMulti = Pip.Spec.isMulti(pubType), subMulti = Pip.Spec.isMulti(subType);
        if (!pubMulti && !subMulti) {
            return mapOne(opts, storage);
        }
        else if (pubMulti && !subMulti) {
            return mapOne(opts, storage);
        }
        else if (!pubMulti && subMulti) {
            return expand(opts, storage);
        }
        else {
            return map(opts, storage);
        }
    }
    function create(linkOptions, storage) {
        if (DEBUG) {
            if (!storage.exists(linkOptions[LO[LO.pub]])) {
                throw new Error('Non-existing pip "' + linkOptions[LO[LO.pub]] + '" prevents creating the link');
            }
            if (!storage.exists(linkOptions[LO[LO.sub]])) {
                throw new Error('Non-existing pip "' + linkOptions[LO[LO.sub]] + '" prevents creating the link');
            }
        }
        var pub = storage.get(linkOptions[LO[LO.pub]]), sub = storage.get(linkOptions[LO[LO.sub]]);
        var pubType = pub.getType(), subType = sub.getType();
        var messageMapper;
        var binding;
        if (pubType === PT[PT.event] || pubType === PT[PT.eventItem]) {
            binding = linkOptions[LO[LO.binding]] === false ? false : true;
        }
        else if (pubType === PT[PT.model] || pubType === PT[PT.collection]) {
            binding = linkOptions[LO[LO.binding]] || false;
        }
        else
            binding = false;
        if (DEBUG && R.find(function (sub) { return sub === linkOptions[LO[LO.sub]]; }, pub.getLinks())) {
            throw new Error('already link defined between pubPip' + linkOptions[LO[LO.pub]] + ' and subPip' + linkOptions[LO[LO.sub]]);
        }
        if (!linkOptions[LO[LO.value]] && !linkOptions[LO[LO.action]] && !linkOptions[LO[LO.pre]] &&
            !linkOptions[LO[LO.filter]] && !linkOptions[LO[LO.sort]]) {
            if (linkOptions[LO[LO.refine]]) {
                var _a = linkOptions[LO[LO.refine]], attr = _a.attr, value = _a.value;
                messageMapper = function (linkIn) {
                    return check(R.reduce(function (acc, message) {
                        if (message.action === 'remove') {
                            acc.push(message);
                        }
                        else {
                            var $elem = message.value;
                            if ($elem.map(DOMIO.getAttr(attr)).runIO() === value) {
                                acc.push(message);
                            }
                        }
                        return acc;
                    }, [], linkIn));
                };
            }
            else {
                messageMapper = function (linkIn) {
                    return check(linkIn);
                };
            }
            ;
        }
        else {
            messageMapper = complexLink(linkOptions, storage, pubType, subType);
        }
        var logger = function (pubType, subType, message) {
            var strlen = 80;
            var val = JSON.stringify(message);
            console.log(linkOptions[LO[LO.pub]] + ':' + pubType + ' - ' + linkOptions[LO[LO.sub]] + ':' + subType + ' = ' +
                (val.length > strlen ? val.substring(0, strlen) + '...' : val));
            return message;
        };
        var fn = function (message) {
            return messageMapper(message);
        };
        var link = {
            sub: linkOptions[LO[LO.sub]],
            subPip: storage.get(linkOptions[LO[LO.sub]]),
            fn: fn
        };
        if (linkOptions[LO[LO.auto]]) {
            link[LO[LO.auto]] = true;
        }
        if (binding && (pubType === PT[PT.event] || pubType === PT[PT.eventItem] ||
            pubType === PT[PT.model] || pubType === PT[PT.collection])) {
            pub.addBinding(link);
        }
        else {
            pub.addLink(link);
            var init = pub.getInit();
            if ((R.is(Array, init) && init.length > 0) || R.keys(init).length > 0) {
                var linkInit = link.fn(init);
                if (linkInit) {
                    if (!R.is(Array, linkInit) || linkInit.length !== 0) {
                        var subPip = link.subPip;
                        subPip.react(linkInit);
                    }
                }
            }
        }
    }
    Links.create = create;
})(Links || (Links = {}));

var Parser;
(function (Parser_1) {
    var Register;
    (function (Register) {
        var ID = '__it';
        var RouterRegister = (function () {
            function RouterRegister(register) {
                this.register = register;
            }
            RouterRegister.prototype.isActive = function (id) {
                return this.register[id] && this.register[id].active === true;
            };
            return RouterRegister;
        })();
        Register.RouterRegister = RouterRegister;
        var Node = (function () {
            function Node(item) {
                this[ID] = item;
            }
            return Node;
        })();
        Register.Node = Node;
        var AST = (function () {
            function AST(rootItem) {
                this.children = [];
                this.root = new Node(rootItem);
            }
            AST.prototype.addChild = function (child) {
                this.children.push(child);
            };
            AST.prototype.toString = function () {
                return this.root !== void 0 ? this.root[ID] : void 0;
            };
            AST.prototype.createUrl = function () {
                if (this.children.length === 0)
                    return this.toString();
                var buf = '';
                if (this.root[ID]) {
                    buf = buf + this.toString() + '/';
                }
                var childStrings = R.map(function (child) { return child.createUrl(); }, this.children);
                buf += childStrings.length === 1
                    ? R.head(childStrings)
                    : '(' + childStrings.join('&') + ')';
                return buf;
            };
            return AST;
        })();
        Register.AST = AST;
        var Parser = (function () {
            function Parser(register) {
                this.register = register;
            }
            Parser.prototype.read = function (navTree) {
                var _this = this;
                var root = R.find(function (item) { return item.__it === 'body'; }, navTree);
                var tree = new AST(root[ID]);
                R.forEach(function (child) { return _this.readItem(child, navTree, tree); }, root.children);
                return tree;
            };
            Parser.prototype.readItem = function (subTreeRoot, navTree, tree) {
                var _this = this;
                if (this.register.isActive(subTreeRoot)) {
                    var subRoot = new AST(subTreeRoot);
                    tree.addChild(subRoot);
                    var children = this.getChildren(subTreeRoot, navTree);
                    R.forEach(function (child) { return _this.readItem(child, navTree, subRoot); }, children);
                }
            };
            Parser.prototype.getChildren = function (item, navTree) {
                var node = R.find(function (it) { return it[ID] === item; }, navTree);
                return node.children;
            };
            return Parser;
        })();
        Register.Parser = Parser;
    })(Register = Parser_1.Register || (Parser_1.Register = {}));
})(Parser || (Parser = {}));

var Parser;
(function (Parser) {
    var Url;
    (function (Url) {
        (function (TOKEN) {
            TOKEN[TOKEN["NAME"] = 0] = "NAME";
            TOKEN[TOKEN["SLASH"] = 1] = "SLASH";
            TOKEN[TOKEN["RPARENTH"] = 2] = "RPARENTH";
            TOKEN[TOKEN["LPARENTH"] = 3] = "LPARENTH";
            TOKEN[TOKEN["AMP"] = 4] = "AMP";
            TOKEN[TOKEN["EOL"] = 5] = "EOL";
        })(Url.TOKEN || (Url.TOKEN = {}));
        var TOKEN = Url.TOKEN;
        ;
        var Token = (function () {
            function Token(type, text) {
                this.type = type;
                this.text = text;
            }
            Token.prototype.toString = function () {
                var tname = TOKEN[TOKEN.NAME];
            };
            return Token;
        })();
        Url.Token = Token;
        var Lexer = (function () {
            function Lexer(input) {
                this.input = input;
                this.p = 0;
                this.c = this.input.charAt(this.p);
            }
            Lexer.prototype.isLetter = function () {
                return this.c !== TOKEN[TOKEN.EOL] && (this.c >= 'a' && this.c <= 'z' || this.c >= 'A' && this.c <= 'Z' || this.c === ' ');
            };
            Lexer.prototype.nextToken = function () {
                while (this.c !== void 0) {
                    switch (this.c) {
                        case '/':
                            this.consume();
                            return new Token(TOKEN.SLASH, "/");
                        case '(':
                            this.consume();
                            return new Token(TOKEN.LPARENTH, "(");
                        case ')':
                            this.consume();
                            return new Token(TOKEN.RPARENTH, ")");
                        case '&':
                            this.consume();
                            return new Token(TOKEN.RPARENTH, "&");
                        default:
                            if (this.isLetter())
                                return this.NAME();
                            throw new TypeError("invalid character: " + this.c);
                    }
                }
                return new Token(TOKEN.EOL, "EOL");
            };
            Lexer.prototype.consume = function () {
                this.p++;
                if (this.p >= this.input.length)
                    this.c = TOKEN[TOKEN.EOL];
                else
                    this.c = this.input.charAt(this.p);
            };
            Lexer.prototype.NAME = function () {
                var buf = '';
                do {
                    buf += this.c;
                    this.consume();
                } while (this.isLetter());
                return new Token(TOKEN.NAME, buf);
            };
            return Lexer;
        })();
        Url.Lexer = Lexer;
    })(Url = Parser.Url || (Parser.Url = {}));
})(Parser || (Parser = {}));

var Pip;
(function (Pip) {
    var Actions;
    (function (Actions) {
        var G = Globals;
        var ACT = G.Action;
        var MK = G.MessageKey;
        function DOMReg(pipIn) {
            var mapping = {
                create: ACT[ACT.create],
                update: ACT[ACT.update],
                'delete': ACT[ACT.update],
                insert: ACT[ACT.create],
                remove: ACT[ACT.delete]
            };
            return mapping[pipIn.action];
        }
        Actions.DOMReg = DOMReg;
        function nodeReg(pipIn) {
            var mapping = {
                create: ACT[ACT.create],
                update: ACT[ACT.update],
                'delete': ACT[ACT.delete],
                insert: ACT[ACT.create],
                remove: ACT[ACT.delete]
            };
            return mapping[pipIn.action];
        }
        Actions.nodeReg = nodeReg;
        function basic(pipIn) {
            var mapping = {
                create: ACT[ACT.create],
                update: ACT[ACT.update],
                'delete': ACT[ACT.delete],
                insert: ACT[ACT.insert],
                remove: ACT[ACT.remove]
            };
            return mapping[pipIn.action];
        }
        Actions.basic = basic;
        function model(pipIn) {
            if (pipIn[MK[MK.action]] === ACT[ACT.create]) {
                return ACT[ACT.create];
            }
            else if (pipIn[MK[MK.action]] === ACT[ACT.update]) {
                if (pipIn[MK[MK.value]] && R.keys(pipIn[MK[MK.value]]).length > 0) {
                    return ACT[ACT.update];
                }
                else {
                    return ACT[ACT.delete];
                }
            }
            else if (pipIn[MK[MK.action]] === ACT[ACT.delete]) {
                return ACT[ACT.delete];
            }
            else if (pipIn[MK[MK.action]] === ACT[ACT.insert]) {
                return ACT[ACT.insert];
            }
            else if (pipIn[MK[MK.action]] === ACT[ACT.remove]) {
                return ACT[ACT.remove];
            }
        }
        Actions.model = model;
        function DOM(pipIn) {
            var mapping = {
                create: ACT[ACT.update],
                update: ACT[ACT.update],
                'delete': ACT[ACT.update],
                insert: ACT[ACT.update],
                remove: ACT[ACT.update]
            };
            return mapping[pipIn.action];
        }
        Actions.DOM = DOM;
        function node(pipIn) {
            var mapping = {
                create: ACT[ACT.insert],
                update: ACT[ACT.insert],
                'delete': ACT[ACT.remove],
                insert: ACT[ACT.insert],
                remove: ACT[ACT.remove]
            };
            return mapping[pipIn.action];
        }
        Actions.node = node;
    })(Actions = Pip.Actions || (Pip.Actions = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Addresses;
    (function (Addresses) {
        var G = Globals;
        var ON = G.OptionName;
        var AK = G.AddressKey;
        function defineSelector(jQueryAchtigeSelectorString) {
            var standardizedSelectorString = jQueryAchtigeSelectorString;
            return standardizedSelectorString;
        }
        Addresses.defineSelector = defineSelector;
        function getTagSelector(selectorString, contextSelector) {
            return (selectorString.substr(0, contextSelector.length) === contextSelector)
                ? selectorString.substr(contextSelector.length + 1)
                : selectorString;
        }
        function findFirstTagOfTpl(tpl) {
            var matches = /<(\w+)\s?.*>/.exec(tpl);
            if (matches && matches.length > 0)
                return matches[1];
            else
                return "";
        }
        function defineEventAddresses(options, regAddressBook, itType) {
            var selector = defineSelector(options[ON[ON.selector]]), address = {}, delegation, regAddresses = regAddressBook[selector];
            address = R.assoc(AK[AK.el], selector, address);
            if (itType) {
                delegation = options[ON[ON.delegation]] == null ? true : options[ON[ON.delegation]];
                address[AK[AK.item]] = regAddresses[AK[AK.item]];
            }
            else {
                delegation = options[ON[ON.delegation]] == null ? false : options[ON[ON.delegation]];
            }
            if (delegation) {
                if (options[ON[ON.root]]) {
                    address[AK[AK.root]] = defineSelector(options[ON[ON.root]]);
                }
                else {
                    if (itType) {
                        address[AK[AK.root]] = regAddresses[AK[AK.root]];
                        address[AK[AK.anc]] = regAddresses[AK[AK.root]];
                    }
                    else {
                        if (regAddresses[AK[AK.anc]].substr(-4) === ".sub") {
                            address[AK[AK.root]] = regAddresses[AK[AK.anc]].substr(0, regAddresses[AK[AK.anc]].length - 4);
                        }
                        else {
                            address[AK[AK.root]] = regAddresses[AK[AK.anc]];
                        }
                    }
                }
                address[AK[AK.anc]] = address[AK[AK.root]];
                address[AK[AK.sel]] = getTagSelector(address[AK[AK.el]], address[AK[AK.root]]);
            }
            else if (itType) {
                address[AK[AK.root]] = regAddresses[AK[AK.root]];
                address[AK[AK.anc]] = regAddresses[AK[AK.pip]];
            }
            else {
                address[AK[AK.anc]] = regAddresses[AK[AK.pip]];
            }
            return address;
        }
        Addresses.defineEventAddresses = defineEventAddresses;
        function defineListAddresses(options) {
            var address = {};
            address[AK[AK.anc]] = defineSelector(options[ON[ON.selector]]);
            address[AK[AK.el]] = address[AK[AK.anc]] + '>' + findFirstTagOfTpl(options[ON[ON.tpl]]);
            return address;
        }
        Addresses.defineListAddresses = defineListAddresses;
        function defineListItemAddresses(options) {
            var address = {};
            var matches = /(.*)>(.*)$/.exec(options[ON[ON.selector]]);
            address[AK[AK.anc]] = defineSelector(matches[1] ? matches[1] : options[ON[ON.selector]]);
            address[AK[AK.sel]] = matches[2] ? matches[2] : '';
            return address;
        }
        Addresses.defineListItemAddresses = defineListItemAddresses;
        function defineTreeNestAddresses(options) {
            var address = {};
            address[AK[AK.anc]] = defineSelector(options[ON[ON.selector]]);
            address[AK[AK.el]] = address[AK[AK.anc]] + '_*';
            return address;
        }
        Addresses.defineTreeNestAddresses = defineTreeNestAddresses;
    })(Addresses = Pip.Addresses || (Pip.Addresses = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Effect;
    (function (Effect) {
        var G = Globals;
        var ACT = G.Action;
        var MK = G.MessageKey;
        var ELM = G.Element;
        var PT = G.PipType;
        var ON = G.OptionName;
        var OV = G.OptionValue;
        var AK = G.AddressKey;
        var AT = G.ApplyType;
        var CT = G.conversionTable;
        function hasEffect(result) {
            return result.effectData !== void 0;
        }
        function mapResultEffect(result, singleEffect, register) {
            if (result instanceof Array) {
                return R.map(function (res) {
                    return singleEffect(res, register, result);
                }, result);
            }
            else {
                return singleEffect(result, register, [result]);
            }
        }
        function DOMSwitchFn() {
            function single(res) {
                if (!hasEffect(res))
                    return void 0;
                var effectData = res.effectData, effect = effectData.effect, DOMInstances = effectData.DOMInstances, $anc = DOMInstances.$anc;
                if ($anc) {
                    res[ELM[ELM.anc]] = $anc;
                    return effect(res);
                }
            }
            return function (result) {
                return mapResultEffect(result, single);
            };
        }
        Effect.DOMSwitchFn = DOMSwitchFn;
        function routerSwitchFn() {
            function filter(res) {
                if (!hasEffect(res))
                    return void 0;
                var effectData = res.effectData, diff = effectData.diff, pipOut = res.pipOut, nowActive = pipOut.value && pipOut.value.active
                    ? pipOut.value.active
                    : false, formerActive = res.oldRegister && res.oldRegister[effectData.it]
                    ? res.oldRegister[effectData.it].active
                    : false;
                var hasEffectOnUrlChange;
                switch (effectData.action) {
                    case ACT[ACT.remove]:
                        hasEffectOnUrlChange = formerActive;
                        break;
                    case ACT[ACT.insert]:
                        hasEffectOnUrlChange = nowActive;
                        break;
                    default:
                        hasEffectOnUrlChange = diff &&
                            ((formerActive !== undefined && nowActive !== formerActive) ||
                                (formerActive === undefined && nowActive));
                }
                return hasEffectOnUrlChange;
            }
            return function (result, register) {
                if (result instanceof Array) {
                    var filtered = R.filter(filter, result);
                    if (filtered.length > 0) {
                        var effect = filtered[0].effectData.effect;
                        var fnKey = (filtered[0].effectData.empty)
                            ? 'E'
                            : 'U';
                        return effect[fnKey](result, register);
                    }
                }
            };
        }
        Effect.routerSwitchFn = routerSwitchFn;
        function subSwitchFn(address) {
            return function (res) {
                if (!hasEffect(res))
                    return void 0;
                var effectData = res.effectData, effect = effectData.effect, DOMInstances = effectData.DOMInstances, diff = effectData.diff, empty = effectData.diff, $anc = DOMInstances.$anc;
                var fnKey;
                if ($anc) {
                    switch (effectData.action) {
                        case ACT[ACT.create]:
                            fnKey = 'C';
                            break;
                        case ACT[ACT.delete]:
                            if (diff && empty) {
                                fnKey = 'E';
                            }
                            break;
                        case ACT[ACT.insert]:
                            if (diff && empty) {
                                fnKey = 'E';
                            }
                            else {
                                fnKey = (res.oldRegister.value === false)
                                    ? 'E'
                                    : 'C';
                            }
                            break;
                        default:
                    }
                }
                if (fnKey && effect[fnKey]) {
                    res[ELM[ELM.root]] = $anc;
                    return effect[fnKey](res);
                }
                else if (fnKey) {
                    throw new Error('unexpected case in subSwitchFn for ' + effectData.action);
                }
            };
        }
        Effect.subSwitchFn = subSwitchFn;
        function listSwitchFn(address) {
            function single(res, register, result) {
                if (!hasEffect(res))
                    return void 0;
                var effectData = res.effectData, effect = effectData.effect, DOMInstances = effectData.DOMInstances, diff = effectData.diff, empty = effectData.empty, $anc = DOMInstances.$anc;
                var fnKey;
                if ($anc) {
                    switch (effectData.action) {
                        case ACT[ACT.create]:
                            fnKey = 'C';
                            break;
                        case ACT[ACT.delete]:
                            if (empty && diff) {
                                fnKey = 'E';
                            }
                            else if (DOMInstances.$el) {
                                fnKey = 'D';
                                res[ELM[ELM.el]] = DOMInstances.$el;
                            }
                            break;
                        case ACT[ACT.update]:
                            if (DOMInstances.$el) {
                                res[ELM[ELM.el]] = DOMInstances.$el;
                                fnKey = 'U';
                            }
                            break;
                        case ACT[ACT.insert]:
                            if (empty || res.oldRegister.value.length === 0) {
                                fnKey = 'E';
                            }
                            else {
                                fnKey = 'C';
                            }
                            break;
                        default:
                            break;
                    }
                }
                if (fnKey && effect[fnKey]) {
                    return effect[fnKey](R.assoc(ELM[ELM.root], $anc, res), register, result);
                }
                else if (fnKey) {
                    throw new Error('unexpected case in listSwitchFn for ' + effectData.action);
                }
            }
            return function (result, register) {
                return mapResultEffect(result, single, register);
            };
        }
        Effect.listSwitchFn = listSwitchFn;
        function eventSwitchFn(pipType, delegation) {
            function single(res) {
                if (!hasEffect(res))
                    return void 0;
                var effectData = res.effectData, effect = effectData.effect, DOMInstances = effectData.DOMInstances, diff = effectData.diff, empty = effectData.diff, action = effectData.action, $anc = DOMInstances.$anc;
                var fn;
                if (pipType === PT[PT.eventItem] || action === ACT[ACT.insert] || action === ACT[ACT.remove] || action === ACT[ACT.update]) {
                    if (delegation) {
                        if (DOMInstances.$root) {
                            res[ELM[ELM.root]] = DOMInstances.$root;
                            fn = effect;
                        }
                    }
                    else if (DOMInstances.$anc) {
                        res[ELM[ELM.anc]] = DOMInstances.$anc;
                        fn = effect;
                    }
                }
                if (fn) {
                    return fn(res);
                }
                else {
                    return void 0;
                }
            }
            return function (result) {
                return mapResultEffect(result, single);
            };
        }
        Effect.eventSwitchFn = eventSwitchFn;
        function modelSwitchFn() {
            function single(res) {
                if (!hasEffect(res))
                    return void 0;
                var effectData = res.effectData, diff = effectData.diff, empty = effectData.empty, emit = res.emit;
                var action;
                switch (effectData.action) {
                    case ACT[ACT.create]:
                        action = 'create';
                        break;
                    case ACT[ACT.delete]:
                        if (diff && empty) {
                            action = 'empty';
                        }
                        else {
                            action = 'delete';
                        }
                        break;
                    case ACT[ACT.update]:
                        action = 'update';
                        break;
                    default:
                        throw new Error('action insert or remove not allowed in modelSwitchFn');
                }
                return [action, res.pipOut];
            }
            return function (result) {
                if (result instanceof Array) {
                    if (result.length > 0) {
                        var effect = result[0].effectData.effect;
                        return effect(R.map(function (res) {
                            return single(res);
                        }, result));
                    }
                }
                else {
                    var effect = result.effectData.effect;
                    return effect([single(result)]);
                }
            };
        }
        Effect.modelSwitchFn = modelSwitchFn;
        function treeSwitchFn() {
            return function (result) {
                var effectData = result.effectData, diff = effectData.diff, empty = effectData.empty, emit = result.emit;
                var action;
                switch (effectData.action) {
                    case ACT[ACT.update]:
                        action = 'update';
                        break;
                    case ACT[ACT.remove]:
                        action = 'empty';
                        break;
                }
                var effect = result.effectData.effect;
                return effect[action](result);
            };
        }
        Effect.treeSwitchFn = treeSwitchFn;
        function routerFn(options, storage) {
            return {
                U: function (evaluated, register) {
                    var navTree = storage.get('navTree').get();
                    if (R.keys(navTree).length > 0) {
                        var reg = new Parser.Register.RouterRegister(register.value);
                        var parser = new Parser.Register.Parser(reg);
                        var ast = parser.read(navTree);
                        ast.createUrl();
                    }
                    return R.pluck('pipOut', evaluated);
                },
                E: function (evaluated) {
                    console.log('empty');
                    return R.pluck('pipOut', evaluated);
                }
            };
        }
        Effect.routerFn = routerFn;
        function nodeDOMFunctions(options, storage, address, itType) {
            function fns($anc, chunk, method) {
                var $chunk = typeof chunk === 'string'
                    ? DOMIO.create(chunk)
                    : chunk;
                DOMIO.manipulate($anc, method, $chunk);
                return itType ? $chunk : $anc;
            }
            function insertOnPosition(index, item, register, result) {
                var $item = typeof item === 'string'
                    ? DOMIO.create(item)
                    : item;
                var $referenceItem;
                var referenceItemIndex = (index === 0) ? 0 : index - 1, itemIdOfReferenceItem = register.value[referenceItemIndex], method = (index === 0) ? OV.insertBefore : OV.insertAfter;
                var listItemRegister = storage.get(address[AK[AK.el]]).get();
                if (R.keys(listItemRegister).length > 0) {
                    $referenceItem = listItemRegister.get(itemIdOfReferenceItem);
                }
                if (!$referenceItem) {
                    $referenceItem = R.path(['pipOut', MK[MK.value]], R.find(function (item) { return R.path(['pipOut', MK[MK.it]], item) === itemIdOfReferenceItem; }, result));
                }
                fns($referenceItem, $item, method);
                return $item;
            }
            var isRegisterEmpty = function (options) {
                return (options[ON[ON.type]] === PT[PT.sub])
                    ? function (register) { return register.value === false; }
                    : function (register) { return register.value.length === 0; };
            }(options);
            return {
                C: (function (options) {
                    return function (evaluated, register, result) {
                        var oldRegister = evaluated.oldRegister;
                        var registerIsEmpty = isRegisterEmpty(oldRegister);
                        if (registerIsEmpty) {
                            fns(evaluated[ELM[ELM.root]], options[ON[ON.empty]], OV.remove);
                        }
                        if (typeof evaluated.pipOut.value === 'number' && !(registerIsEmpty && evaluated.pipOut.value === 0)) {
                            evaluated.pipOut.value = insertOnPosition(evaluated.pipOut.value, options[ON[ON.tpl]], register, result);
                        }
                        else {
                            evaluated.pipOut.value = fns(evaluated[ELM[ELM.root]], options[ON[ON.tpl]], OV.append);
                        }
                        return evaluated.pipOut;
                    };
                }(options)),
                U: (function (options) {
                    if (options[ON[ON.type]] === PT[PT.list]) {
                        function findIndex(itemId, register) {
                            var temp = itemId.split(G.MERGETOKEN), id = temp[0];
                            return R.indexOf(id, R.map(function (val) { return val.split(G.MERGETOKEN)[0]; }, register.value));
                        }
                        ;
                        return function (evaluated, register, result) {
                            if (typeof evaluated.pipOut.value === 'number') {
                                var regPosition = findIndex(evaluated.effectData.it, register);
                                if (evaluated.pipOut.value !== regPosition) {
                                    var $item = evaluated[ELM[ELM.el]].map(DOMIO.detachElement).runIO();
                                    evaluated.pipOut.value = insertOnPosition(evaluated.pipOut.value, $item, register, result);
                                }
                            }
                            return evaluated.pipOut;
                        };
                    }
                }(options)),
                D: function (evaluated) {
                    evaluated[ELM[ELM.el]].map(DOMIO.remove).runIO();
                    return evaluated.pipOut;
                },
                E: (function (options) {
                    return function (evaluated) {
                        var $root = evaluated[ELM[ELM.root]];
                        R.map(DOMIO.empty, $root).runIO();
                        if (options[ON[ON.empty]]) {
                            fns($root, options[ON[ON.empty]], OV.append);
                        }
                        return evaluated.pipOut;
                    };
                }(options))
            };
        }
        Effect.nodeDOMFunctions = nodeDOMFunctions;
        function serverFn(options, serverIO, address, storage) {
            var index = options[ON[ON.index]] || G.serverIndexAttr;
            return function (res) {
                var _a = res[0], action = _a[0], pipOut = _a[1];
                var emit = pipOut.emit;
                if (emit) {
                    var future = serverIO.sync(res);
                    future.fork(function (err) { throw new Error(err); }, function (pipout) {
                        var pip = storage.get(address[AK[AK.pip]]);
                        var bindings = pip.getBindings();
                        R.forEach(function (binding) {
                            var bindingOut = binding.fn(pipOut);
                            if (bindingOut) {
                                if (!R.is(Array, bindingOut) || bindingOut.length !== 0) {
                                    var subPip = binding.subPip;
                                    return subPip.react(bindingOut);
                                }
                            }
                        }, bindings);
                    });
                }
                return R.map(function (out) {
                    var action = out[0], pipOut = out[1];
                    pipOut.emit = false;
                    return pipOut;
                }, res);
            };
        }
        Effect.serverFn = serverFn;
        function eventDOMFunctions(options, address, storage) {
            var fns = (function () {
                var delegation = options[ON[ON.delegation]];
                var itemType = options.type === PT[PT.eventItem];
                var ancestorType = storage.get(itemType ? address[AK[AK.root]] : address[AK[AK.anc]]).getType();
                var itType = itemType && !delegation;
                var preventDefault = options[ON[ON.preventDefault]] == null ? true : options[ON[ON.preventDefault]];
                var eventNames = options[ON[ON.events]] || G.defaultEvents;
                function loopBindings(eventObject) {
                    if (eventObject) {
                        var eventMessage = itemType
                            ? [eventObject]
                            : eventObject;
                        R.forEach(function (binding) {
                            var bindingOut = binding.fn(eventMessage);
                            if (bindingOut) {
                                if (!R.is(Array, bindingOut) || bindingOut.length !== 0) {
                                    var subPip = binding.subPip;
                                    subPip.react(bindingOut);
                                }
                            }
                        }, storage.get(address[AK[AK.pip]]).getBindings());
                    }
                }
                function composeInterpretEvent() {
                    if (itemType) {
                        if (ancestorType === PT[PT.itemElement]) {
                            if (!delegation) {
                                return function (evt) {
                                    var eObject = {
                                        evt: evt,
                                        root: evt.data[1],
                                        el: evt.data[0],
                                        it: storage.get(address[AK[AK.el]]).getItemId(evt.data[0])
                                    };
                                    eObject.item =
                                        storage.get(address[AK[AK.item]]).get(eObject[MK[MK.it]]);
                                    return eObject;
                                };
                            }
                            else {
                                return function (evt) {
                                    var $el = DOMIO.create($(evt.currentTarget));
                                    var eObject = {
                                        evt: evt,
                                        root: evt.data[1],
                                        el: $el,
                                        it: storage.get(address[AK[AK.el]]).getItemId($el)
                                    };
                                    eObject.item = storage.get(address[AK[AK.item]]).get(eObject[MK[MK.it]]);
                                    return eObject;
                                };
                            }
                        }
                        else {
                            if (!delegation) {
                                return function (evt) {
                                    return {
                                        evt: evt,
                                        root: evt.data[1],
                                        item: evt.data[0],
                                        it: storage.get(address[AK[AK.el]]).getItemId(evt.data[0])
                                    };
                                };
                            }
                            else {
                                return function (evt) {
                                    var $item = DOMIO.create($(evt.currentTarget));
                                    return {
                                        evt: evt,
                                        root: evt.data[1],
                                        item: $item,
                                        it: storage.get(address[AK[AK.el]]).getItemId($item)
                                    };
                                };
                            }
                        }
                    }
                    else if (delegation) {
                        return function (evt) {
                            var $el = DOMIO.create($(evt.currentTarget));
                            return {
                                evt: evt,
                                root: evt.data[1],
                                el: $el
                            };
                        };
                    }
                    else {
                        return function (evt) {
                            return {
                                evt: evt,
                                el: evt.data[0]
                            };
                        };
                    }
                }
                function composeEventFunction(interpretEvent) {
                    if (options[ON[ON.bindFn]] || preventDefault) {
                        if (options[ON[ON.bindFn]] && preventDefault) {
                            return function (evt) {
                                DOMIO.preventDefault(evt);
                                var eventObject = interpretEvent(evt);
                                if (eventObject) {
                                    var bindObject = options[ON[ON.bindFn]](eventObject);
                                    loopBindings(bindObject);
                                }
                            };
                        }
                        else if (preventDefault) {
                            return function (evt) {
                                DOMIO.preventDefault(evt);
                                var eventObject = interpretEvent(evt);
                                loopBindings(eventObject);
                            };
                        }
                        else {
                            return function (evt) {
                                var eventObject = interpretEvent(evt);
                                if (eventObject) {
                                    var bindObject = options[ON[ON.bindFn]](eventObject);
                                    loopBindings(bindObject);
                                }
                            };
                        }
                    }
                    else {
                        return function (evt) {
                            var eventObject = interpretEvent(evt);
                            loopBindings(eventObject);
                        };
                    }
                }
                function composeDelegateEvents(eventFunction) {
                    var evtNames = eventNames.split(/\s+/);
                    return R.map(function (evtName) {
                        evtName += '.' + address[AK[AK.pip]];
                        if (delegation) {
                            return function ($el, $root) {
                                return $root.map(DOMIO.addEvent(evtName, address[AK[AK.sel]], [$el, $root], eventFunction));
                            };
                        }
                        else {
                            return function ($el, $root, itemId) {
                                var eventName = itemId ? evtName + itemId : evtName;
                                return $el.map(DOMIO.addEvent(eventName, [$el, $root], eventFunction));
                            };
                        }
                    }, evtNames);
                }
                function composeUnDelegateEvents() {
                    var evtNames = eventNames.split(/\s+/);
                    return R.map(function (evtName) {
                        evtName += '.' + address[AK[AK.pip]];
                        if (delegation) {
                            return function ($el, $root) {
                                return $root.map(DOMIO.removeEvent(evtName, address[AK[AK.sel]]));
                            };
                        }
                        else {
                            return function ($el, $root, itemId) {
                                var eventName = itemId ? evtName + itemId : evtName;
                                return $el.map(DOMIO.removeEvent(eventName));
                            };
                        }
                    }, evtNames);
                }
                var interpretEvent = composeInterpretEvent();
                var eventFunction = composeEventFunction(interpretEvent);
                var delegations = composeDelegateEvents(eventFunction);
                var unDelegations = composeUnDelegateEvents();
                return {
                    'true': function (evaluated) {
                        var $el = evaluated[ELM[ELM.anc]];
                        var $root = evaluated[ELM[ELM.root]];
                        var itemId = evaluated.effectData[MK[MK.it]];
                        R.forEach(function (delegate) {
                            delegate($el, $root, itemId).runIO();
                        }, delegations);
                    },
                    'false': function (evaluated) {
                        var $el = evaluated[ELM[ELM.anc]];
                        var $root = evaluated[ELM[ELM.root]];
                        var itemId = evaluated.effectData[MK[MK.it]];
                        R.forEach(function (unDelegate) {
                            unDelegate($el, $root, itemId).runIO();
                        }, unDelegations);
                    }
                };
            }());
            return function (evaluated) {
                fns[evaluated.pipOut[MK[MK.value]]](evaluated);
                return evaluated.pipOut;
            };
        }
        Effect.eventDOMFunctions = eventDOMFunctions;
        function stateDOMFn(options) {
            function createStateFunctions(stateFuncs) {
                var fns = {};
                R.mapObjIndexed(function (mainFns, mainKey, all) {
                    var fn;
                    R.mapObjIndexed(function (itemFns, itemKey, itemAll) {
                        if (itemKey === mainKey) {
                            fn = fn
                                ? R.compose(R.map(itemFns['activate']), fn)
                                : R.map(itemFns['activate']);
                        }
                        else if (itemFns['deactivate']) {
                            fn = fn
                                ? R.compose(fn, R.map(itemFns['deactivate']))
                                : R.map(itemFns['deactivate']);
                        }
                    }, stateFuncs);
                    fns[mainKey] = fn;
                }, stateFuncs);
                return fns;
            }
            function stateApplyObjectFactory(states) {
                return R.zipObj(R.pluck(ON[ON.name], states), R.map(stateSetters, states));
            }
            function stateSetters(state) {
                switch (getApplyType(state[ON[ON.attr]])) {
                    case AT[AT.cl]:
                        return {
                            activate: DOMIO.addClass(state[ON[ON.value]]),
                            deactivate: DOMIO.removeClass(state[ON[ON.value]])
                        };
                    case AT[AT.css]:
                        return {
                            activate: DOMIO.addCss(R.pick([ON[ON.attr], ON[ON.value]], state))
                        };
                    case AT[AT.attr]:
                        return {
                            activate: DOMIO.addAttr(R.pick([ON[ON.attr], ON[ON.value]], state))
                        };
                    case AT[AT.prop]:
                        if (state[ON[ON.value]] === true) {
                            return {
                                activate: DOMIO.addProp(state[ON[ON.attr]])
                            };
                        }
                        else {
                            return {
                                activate: DOMIO.removeProp(state[ON[ON.attr]])
                            };
                        }
                }
            }
            function getApplyType(attr) {
                return CT[attr];
            }
            var fns = createStateFunctions(stateApplyObjectFactory(options[ON[ON.states]]));
            return function (evaluated) {
                fns[evaluated.pipOut[MK[MK.value]]](evaluated[ELM[ELM.anc]]).runIO();
                return evaluated.pipOut;
            };
        }
        Effect.stateDOMFn = stateDOMFn;
        function templateDOMFn(options) {
            var attributeName = options[ON[ON.attr]] || OV[OV.html];
            var fns = function (tpl, $el) {
                if ($el === void 0)
                    return void 0;
                if (attributeName === OV[OV.html]) {
                    var method = options[ON[ON.method]] || OV[OV.html];
                    switch (method) {
                        case OV[OV.prepend]:
                            $el.map(DOMIO.prependString(tpl)).runIO();
                            break;
                        case OV[OV.append]:
                            $el.map(DOMIO.appendString(tpl)).runIO();
                            break;
                        default: $el.map(DOMIO.html(tpl)).runIO();
                    }
                }
                else if (attributeName === 'value') {
                    $el.map(DOMIO.setVal(tpl)).runIO();
                }
                else {
                    var attr = {};
                    attr[attributeName] = tpl;
                    $el.map(DOMIO.addAttr(attr)).runIO();
                }
            };
            return function (evaluated) {
                fns(evaluated.pipOut[MK[MK.value]], evaluated[ELM[ELM.anc]]);
                return evaluated.pipOut;
            };
        }
        Effect.templateDOMFn = templateDOMFn;
    })(Effect = Pip.Effect || (Pip.Effect = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Input;
    (function (Input) {
        var G = Globals;
        var ACT = G.Action;
        var MK = G.MessageKey;
        var ON = G.OptionName;
        var AK = G.AddressKey;
        var DIR = G.Direction;
        function filterShadow(options, address) {
            var lastItemId;
            var selector = address[AK[AK.sel]];
            var itemNr = parseInt(R.slice(1, Infinity, selector), 10);
            return function (pipIn) {
                var $shadowEl, message = null;
                if (pipIn[itemNr][MK[MK.action]] === ACT[ACT.remove]) {
                    console.log('not correctly implemented yet');
                    if (lastItemId === pipIn[itemNr][MK[MK.it]]) {
                        message[MK[MK.action]] = pipIn[itemNr][MK[MK.action]];
                    }
                }
                else {
                    $shadowEl = pipIn[itemNr][MK[MK.value]];
                    if ($shadowEl) {
                        message = pipIn[itemNr];
                    }
                }
                return message ? message : null;
            };
        }
        Input.filterShadow = filterShadow;
        function defineInit(action) {
            var message = {};
            message[MK[MK.action]] = action;
            return message;
        }
        Input.defineInit = defineInit;
        function defineModelInit(options) {
            var message = {};
            message[MK[MK.action]] = ACT[ACT.delete];
            var initModel = {};
            if (options[ON[ON.model]]) {
                var model = options[ON[ON.model]];
                for (var key in model) {
                    if (model[key] !== undefined) {
                        initModel[key] = model[key];
                    }
                }
                if (R.keys(initModel).length !== 0) {
                    message[MK[MK.action]] = ACT[ACT.create];
                    message[MK[MK.value]] = initModel;
                }
            }
            if (!message) {
                message[MK[MK.action]] = ACT[ACT.delete];
            }
            return message;
        }
        Input.defineModelInit = defineModelInit;
        function defineCollectionInit(options) {
            var message, initCollection = [];
            if (options[ON[ON.model]]) {
                var models = R.is(Array, options[ON[ON.model]])
                    ? options[ON[ON.model]]
                    : [options[ON[ON.model]]];
                for (var i = 0, len = models.length; i < len; i++) {
                    var model = models[i];
                    var initModel = {};
                    for (var key in model) {
                        if (model[key] !== undefined) {
                            initModel[key] = model[key];
                        }
                    }
                    if (R.keys(initModel).length !== 0) {
                        message = message || [];
                        var obj = {};
                        obj[MK[MK.action]] = ACT[ACT.create];
                        obj[MK[MK.value]] = initModel;
                        obj[MK[MK.it]] = ObjectId.create();
                        message.push(obj);
                    }
                }
            }
            if (!message) {
                message = {};
                message[MK[MK.action]] = ACT[ACT.delete];
            }
            return message;
        }
        Input.defineCollectionInit = defineCollectionInit;
        function initDOMList(options, address, storage) {
            return function (pipIn) {
                var $root = pipIn[MK[MK.value]] || storage.get(address[AK[AK.anc]]).get();
                var it = address[AK[AK.sel]];
                var $items = DOMIO.createScoped($root, it);
                return DOMIO.mapItems(function (elem) {
                    var itemId = options[ON[ON.idType]]
                        ? DOMIO.getDOMItemId(options[ON[ON.idType]], elem)
                        : ObjectId.create();
                    return {
                        it: itemId,
                        action: ACT[ACT.insert],
                        value: DOMIO.create(elem)
                    };
                }, $items);
            };
        }
        Input.initDOMList = initDOMList;
        function correctList(options) {
            function sortOnPipCondition(pipIn) {
                var sort = options.sort;
                var sortCriteria = R.is(Array, sort)
                    ? sort
                    : [sort];
                var sortFunction = function (sortCriterion) {
                    return !sortCriterion.dir || sortCriterion.dir.toUpperCase() === DIR[DIR.ASC]
                        ? function (a, b) {
                            return a.value[sortCriterion.key] <= b.value[sortCriterion.key] ? -1 : 1;
                        }
                        : function (a, b) {
                            return a.value[sortCriterion.key] > b.value[sortCriterion.key] ? -1 : 1;
                        };
                };
                var sortedInput = R.clone(pipIn);
                R.forEach(function (criterion) {
                    sortedInput = R.sort(sortFunction(criterion), sortedInput);
                }, sortCriteria);
                return sortedInput;
            }
            function redefineSortedInput(input) {
                var desiredIndex = 0, addedDesiredIndex = R.map(function (inp) {
                    if (inp[MK[MK.action]] !== ACT[ACT.delete]) {
                        if (!R.contains(G.POS, R.keys(inp[MK[MK.value]]))) {
                            inp[MK[MK.value]][G.POS] = desiredIndex;
                            desiredIndex++;
                        }
                    }
                    return inp;
                }, input);
                var deletedFirst = [];
                R.forEach(function (item) {
                    if (item[MK[MK.action]] === ACT[ACT.delete]) {
                        deletedFirst.unshift(item);
                    }
                    else {
                        deletedFirst.push(item);
                    }
                }, addedDesiredIndex);
                return deletedFirst;
            }
            function testFilterConditions(value) {
                var conditions = options.filter, allConditionsAreMet = true;
                for (var key in conditions) {
                    if (value[key] !== conditions[key]) {
                        allConditionsAreMet = false;
                    }
                }
                return allConditionsAreMet;
            }
            return function (pipIn) {
                var correctedInput = [], redefinitionNeeded = false;
                if (options[ON[ON.filter]]) {
                    correctedInput = R.filter(function (inp) { return testFilterConditions(inp[MK[MK.value]]); }, pipIn);
                }
                else {
                    correctedInput = pipIn;
                }
                if (R.find(function (inp) { return inp[MK[MK.action]] === ACT[ACT.update]; }, pipIn)) {
                    redefinitionNeeded = true;
                }
                if (options[ON[ON.sort]]) {
                    correctedInput = sortOnPipCondition(correctedInput);
                    redefinitionNeeded = true;
                }
                if (redefinitionNeeded) {
                    correctedInput = redefineSortedInput(correctedInput);
                }
                return correctedInput;
            };
        }
        Input.correctList = correctList;
        function correctSelection(options) {
            var one = options[ON[ON.one]] === undefined ? true : options[ON[ON.one]], required = options[ON[ON.required]] === undefined ? false : options[ON[ON.required]], reselectable = options[ON[ON.reselectable]] === undefined ? false : options[ON[ON.reselectable]];
            function getDups(pipIn, selected) {
                return R.intersection(selected, R.pluck(MK[MK.it], R.filter(function (inp) { return inp[MK[MK.value]] === true; }, pipIn)));
            }
            function getTruthies(pipIn) {
                return R.pluck(MK[MK.it], R.filter(function (inp) { return inp[MK[MK.value]] === true; }, pipIn));
            }
            function getFalsies(pipIn) {
                return R.pluck(MK[MK.it], R.filter(function (inp) { return inp[MK[MK.value]] === false; }, pipIn));
            }
            function constructOut(ids, active, originalTruthies) {
                return R.map(function (inp) {
                    if ((active === true && !R.contains(inp, originalTruthies)) ||
                        (active === false && R.contains(inp, originalTruthies))) {
                        return R.assoc(MK[MK.emit], true, { action: ACT[ACT.update], value: active, it: inp });
                    }
                    else {
                        return { action: ACT[ACT.update], value: active, it: inp };
                    }
                }, ids);
            }
            return function (pipIn, register, defineItemId) {
                //TODO soms it !== getItemId(it)
                var dups = getDups(pipIn, register.value);
                var originalTruthies = getTruthies(pipIn);
                var truthies = R.union(register.value, originalTruthies);
                var falsies = getFalsies(pipIn);
                if (dups.length > 0) {
                    if (reselectable === true) {
                        truthies = R.union(truthies, dups);
                        falsies = R.difference(falsies, dups);
                    }
                    else {
                        truthies = R.difference(truthies, dups);
                        falsies = R.union(falsies, dups);
                    }
                }
                if (one === true) {
                    if (truthies.length > 1) {
                        var solo = [R.head(originalTruthies) || R.head(truthies)];
                        var moreFalsies = R.difference(truthies, solo);
                        falsies = R.union(moreFalsies, falsies);
                        truthies = solo;
                    }
                }
                if (required === true) {
                    if (truthies.length === 0) {
                        truthies = register.value.length > 0
                            ? [R.head(register.value)]
                            : falsies.length > 0
                                ? [R.head(falsies)]
                                : [];
                        falsies = R.difference(falsies, truthies);
                    }
                }
                falsies = R.difference(falsies, truthies);
                return R.union(constructOut(truthies, true, originalTruthies), constructOut(falsies, false, originalTruthies));
            };
        }
        Input.correctSelection = correctSelection;
        function correctNavTree(options) {
            var navTree = options.navTree;
            return function (pipIn, register, defineItemId) {
                var messages = [];
                R.forEach(function (input) {
                    messages.push(input);
                    var parentId = input[MK[MK.value]].anc
                        ? navTree[input[MK[MK.value]].anc]
                        : navTree[input[MK[MK.it]]];
                    messages.push({
                        it: parentId,
                        action: input[MK[MK.action]] === ACT[ACT.insert]
                            ? ACT[ACT.create]
                            : ACT[ACT.update],
                        value: input[MK[MK.it]]
                    });
                }, pipIn);
                return messages;
            };
        }
        Input.correctNavTree = correctNavTree;
        function trueTest(action) {
            return true;
        }
        Input.trueTest = trueTest;
        function falseTest(action) {
            return false;
        }
        Input.falseTest = falseTest;
        function insertTest(action) {
            return action === ACT[ACT.insert];
        }
        Input.insertTest = insertTest;
        function DOMTest(action) {
            return action === ACT[ACT.insert] || action === ACT[ACT.remove];
        }
        Input.DOMTest = DOMTest;
        function destructTest(action) {
            return action === ACT[ACT.delete] || action === ACT[ACT.remove];
        }
        Input.destructTest = destructTest;
    })(Input = Pip.Input || (Pip.Input = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Interpret;
    (function (Interpret) {
        var G = Globals;
        var PT = G.PipType;
        var ACT = G.Action;
        var MK = G.MessageKey;
        var AK = G.AddressKey;
        var PC = G.PipClass;
        function base(address, pipProps, storage) {
            var assembleRegMutator = (function (pipProps) {
                var defaultValue = pipProps.values.defaultValue();
                return function (regDiff, mutator, action, desiredValue, oldRegister, itemId) {
                    var oldRegisterValue = pipProps.itType ? oldRegister.value[itemId] : oldRegister.value;
                    if (regDiff || ((action === ACT[ACT.remove] || action === ACT[ACT.delete])))
                        return {
                            mutator: mutator,
                            action: action,
                            desiredValue: desiredValue,
                            itemId: itemId,
                            old: oldRegister
                        };
                    else
                        return void 0;
                };
            })(pipProps);
            return function interpret(pipIn, register, it) {
                var outAction = pipProps.outActions(pipIn), regAction = pipProps.regActions(pipIn), desiredValue;
                switch (pipIn[MK[MK.action]]) {
                    case ACT[ACT.create]:
                        desiredValue = pipProps.values.create(pipIn, register, it);
                        break;
                    case ACT[ACT.insert]:
                        desiredValue = pipProps.values.insert(pipIn, register, pipProps.values.defaultValue(), it);
                        break;
                    case ACT[ACT.update]:
                        desiredValue = pipProps.values.update(pipIn, register, it);
                        break;
                    default: desiredValue = it ? pipProps.values.defaultValue() : pipProps.values.reg();
                }
                var regDiff = pipProps.diffTest(desiredValue, register, it);
                var diff = regDiff || pipIn.emit === true;
                var empty = !it && (pipIn[MK[MK.action]] === ACT[ACT.delete] || pipIn[MK[MK.action]] === ACT[ACT.remove]);
                var DOMInstances = {
                    $anc: getAncestor(storage, address, pipIn, pipProps, it),
                    $root: getRoot(storage, address, pipProps),
                    $el: getElement(storage, address, pipProps, pipIn[MK[MK.action]], it)
                };
                var oldRegister = R.clone(register);
                var result = {
                    pipOut: createPipOut(pipIn, diff, empty, outAction, desiredValue, pipProps, register),
                    reg: assembleRegMutator(regDiff, pipProps.setReg, regAction, desiredValue, oldRegister, it),
                    oldRegister: oldRegister,
                    emit: pipProps.emitTest(diff, pipIn[MK[MK.action]], empty, DOMInstances.$anc),
                    effectData: void 0
                };
                if (!pipIn.init && pipProps.switchFn && (diff || pipIn[MK[MK.action]] === ACT[ACT.insert] || pipIn[MK[MK.action]] === ACT[ACT.delete])) {
                    result.effectData = {
                        effect: pipProps.pipFn,
                        diff: diff,
                        empty: empty,
                        action: pipIn[MK[MK.action]],
                        DOMInstances: DOMInstances,
                        it: it
                    };
                }
                return result;
            };
        }
        Interpret.base = base;
        function getAncestor(storage, address, pipIn, pipProps, it) {
            var $anc;
            if (address[AK[AK.anc]]) {
                if (pipIn[MK[MK.action]] === ACT[ACT.insert]) {
                    $anc = pipIn[MK[MK.value]];
                }
                else if (it && pipProps.pipType !== PT[PT.list] && pipProps.pipType !== PT[PT.select] && pipProps.pipType !== PT[PT.targetItem]) {
                    $anc = storage.get(address[AK[AK.anc]]).unsafeGet(it);
                }
                else {
                    $anc = storage.get(address[AK[AK.anc]]).unsafeGet();
                }
                if (!$anc || !$anc.fn)
                    $anc = void 0;
            }
            return $anc;
        }
        function getRoot(storage, address, pipProps) {
            var $root;
            if (pipProps.pipClass === PC[PC.enable] && address[AK[AK.root]]) {
                $root = storage.get(address[AK[AK.root]]).unsafeGet();
                if (!$root || !$root.fn)
                    $root = void 0;
            }
            return $root;
        }
        function getElement(storage, address, pipProps, action, it) {
            var $el;
            if (pipProps.pipType === PT[PT.list] && (action === ACT[ACT.delete] || action === ACT[ACT.update]) && it) {
                $el = storage.get(address[AK[AK.el]]).unsafeGet(it);
                if (!$el || !$el.fn)
                    $el = void 0;
            }
            else if (address[AK[AK.el]] && pipProps.pipClass === PC[PC.enable]) {
                switch (pipProps.pipType) {
                    case PT[PT.event]:
                        $el = storage.get(address[AK[AK.el]]).unsafeGet();
                        break;
                    case PT[PT.eventItem]:
                        $el = storage.get(address[AK[AK.el]]).unsafeGet(it);
                        break;
                    default:
                        throw new Error('unexpected case in interpret::getElement');
                }
            }
            return $el;
        }
        function createPipOut(pipIn, diff, empty, action, desiredValue, pipProps, register) {
            if (empty && pipProps.itType) {
                if (R.is(Array, register.value)) {
                    return R.map(function (regVal) {
                        return {
                            action: action,
                            it: regVal,
                            value: pipProps.values.defaultValue()
                        };
                    }, register.value);
                }
                else {
                    var pipOut = [];
                    for (var itId in register.value) {
                        if (pipProps.diffTest(pipProps.values.defaultValue(), register, itId)) {
                            var obj = {};
                            obj[MK[MK.action]] = action;
                            obj[MK[MK.it]] = itId;
                            obj[MK[MK.value]] = pipProps.values.defaultValue();
                            if (pipProps.pipType === PT[PT.router] && pipIn[MK[MK.value]].anc)
                                obj[MK[MK.value]].anc = pipIn[MK[MK.value]].anc;
                            pipOut.push(obj);
                        }
                    }
                    return pipOut;
                }
            }
            else if (diff || pipIn[MK[MK.action]] === ACT[ACT.insert] || pipIn[MK[MK.action]] === ACT[ACT.delete]) {
                var pipOut = {};
                pipOut[MK[MK.action]] = action;
                pipOut[MK[MK.value]] = desiredValue;
                if (pipProps.pipType === PT[PT.router] && pipIn[MK[MK.action]] === ACT[ACT.remove] && pipIn[MK[MK.value]].anc)
                    desiredValue.anc = pipIn[MK[MK.value]].anc;
                if (pipProps.pipClass === PC[PC.attr] && pipIn[MK[MK.emit]] === void 0)
                    pipOut[MK[MK.emit]] = true;
                return pipOut;
            }
            else
                return void 0;
        }
        function item(address, pipProps, storage) {
            var baseFn = base(address, pipProps, storage);
            function itemFn(pipIn, register) {
                if (pipIn instanceof Array) {
                    return emptyTest(pipIn, register, pipProps.defineItemId)
                        ? (pipProps.emptyInput instanceof Array)
                            ? multiFn(pipProps.emptyInput, register)
                            : baseFn(pipProps.emptyInput, register)
                        : multiFn(pipIn, register);
                }
                else {
                    if (pipIn[MK[MK.action]] === ACT[ACT.delete] || pipIn[MK[MK.action]] === ACT[ACT.remove]) {
                        var itemIds = R.is(Array, register.value)
                            ? register.value
                            : R.keys(register.value);
                        return multiFn(R.map(function (itemId) {
                            return R.zipObj([MK[MK.action], MK[MK.it]], [pipIn[MK[MK.action]], itemId]);
                        }, itemIds), register);
                    }
                    else {
                        return null;
                    }
                }
            }
            function multiFn(pipIn, register) {
                return R.map(function (pipInp) {
                    var itemId = pipProps.defineItemId(pipInp, register);
                    var aObj = baseFn(pipInp, register, itemId);
                    if (aObj.pipOut) {
                        aObj.pipOut[MK[MK.it]] = itemId;
                    }
                    return aObj;
                }, pipIn);
            }
            return itemFn;
        }
        Interpret.item = item;
        function correct(address, pipProps, storage) {
            var baseFn = base(address, pipProps, storage);
            var itemFn = pipProps.itType ? item(address, pipProps, storage) : null;
            var correctFn = function (pipIn, register) {
                var correctedInput = pipProps.correctInput.define(pipIn, register, pipProps.defineItemId);
                if (correctedInput) {
                    return itemFn ? itemFn(correctedInput, register) : baseFn(correctedInput, register);
                }
            };
            return function (pipIn, register) {
                if (pipIn instanceof Array) {
                    return pipProps.pipType === PT[PT.listItem] ? itemFn(pipIn, register) : correctFn(pipIn, register);
                }
                else if (pipProps.correctInput.baseActionTest(pipIn[MK[MK.action]])) {
                    return pipProps.pipType === PT[PT.listItem] ? correctFn(pipIn, register) : baseFn(pipIn, register);
                }
                else if (pipProps.correctInput.emptyActionTest(pipIn[MK[MK.action]])) {
                    return baseFn(pipProps.emptyInput, register);
                }
                else {
                    throw new Error('correct can not interpret given input');
                }
            };
        }
        Interpret.correct = correct;
        function emptyTest(pipIn, register, defineItemId) {
            if (!(pipIn instanceof Array))
                throw new Error('emptyTest requires a array of pipIn');
            var empty = false, itemIds = R.is(Array, register.value)
                ? register.value
                : R.keys(register.value), nrOfItems = itemIds.length, len = pipIn.length;
            if (len === nrOfItems) {
                var actionValues = R.uniq(R.pluck(MK[MK.action], pipIn));
                if (actionValues.length === 1 && (actionValues[0] === ACT[ACT.delete] || actionValues[0] === ACT[ACT.remove])) {
                    var pipInItems = R.map(function (inp) {
                        return defineItemId(inp, register);
                    }, pipIn);
                    if ((R.union(pipInItems, itemIds)).length === nrOfItems) {
                        empty = true;
                    }
                }
            }
            return empty;
        }
    })(Interpret = Pip.Interpret || (Pip.Interpret = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var ItemId;
    (function (ItemId) {
        var G = Globals;
        var MK = G.MessageKey;
        var ON = G.OptionName;
        function splitId(id) {
            return id.split(G.MERGETOKEN);
        }
        function extractMid(splitId) {
            return splitId[0];
        }
        function getMid(itemInput) {
            var it = itemInput
                ? itemInput[MK[MK.it]]
                : null;
            if (it) {
                return extractMid(splitId(it));
            }
            else {
                return ObjectId.create();
            }
        }
        ItemId.getMid = getMid;
        function map(itemInput, register) {
            var idIn = itemInput[MK[MK.it]], registerIds = R.is(Array, register.value)
                ? register.value
                : R.keys(register.value), nrRegisterIds = registerIds.length, dualIdIn = splitId(idIn), itemId, mid;
            if (nrRegisterIds !== 0) {
                var i = 0;
                while (!itemId && i < nrRegisterIds) {
                    if (idIn === registerIds[i]) {
                        itemId = idIn;
                    }
                    else {
                        var dualRegisterId = splitId(registerIds[i]);
                        if (dualRegisterId.length > 1) {
                            mid = extractMid(dualRegisterId);
                            if (mid === idIn) {
                                itemId = registerIds[i];
                            }
                        }
                        else if (dualIdIn.length > 1) {
                            mid = extractMid(dualIdIn);
                            if (register.value[mid]) {
                                var registerValue = register.value[mid];
                                if (R.is(Array, register.value)) {
                                    var index = R.indexOf(mid, register.value);
                                    register.value.slice(index, index + 1);
                                    register.value.push(itemId);
                                }
                                else {
                                    delete register.value[mid];
                                    register.value[idIn] = registerValue;
                                }
                            }
                            itemId = idIn;
                        }
                    }
                    i++;
                }
            }
            return itemId || idIn;
        }
        ItemId.map = map;
        function node(options) {
            return options[ON[ON.idKey]]
                ? function (itemInput, register) {
                    var idKey = itemInput[MK[MK.value]]
                        ? itemInput[MK[MK.value]][options[ON[ON.idKey]]]
                        : void 0;
                    return idKey
                        ? itemInput[MK[MK.it]] + G.MERGETOKEN + idKey
                        : map(itemInput, register);
                }
                : function (itemInput) {
                    return itemInput[MK[MK.it]];
                };
        }
        ItemId.node = node;
    })(ItemId = Pip.ItemId || (Pip.ItemId = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Options;
    (function (Options) {
        var D = DefaultValues;
        Options.defaults = {
            event: {
                events: D.DEFAULTEVENTS,
                enable: true,
                preventDefault: true,
                delegation: false
            },
            eventItem: {
                events: D.DEFAULTEVENTS,
                enable: true,
                preventDefault: true,
                delegation: true
            },
            state: {},
            stateItem: {},
            template: {
                attr: 'html',
                method: 'html',
                empty: ''
            },
            templateItem: {
                attr: 'html',
                method: 'html',
                empty: ''
            },
            element: {},
            shadowElement: {},
            listItem: {},
            itemElement: {},
            sub: {
                method: 'html',
                empty: ''
            },
            list: {
                method: 'html',
                empty: '',
                it: 'li'
            },
            select: {
                one: true,
                required: true,
                reselectable: false,
                states: D.STATES_SELECT
            },
            target: {
                router: true,
                states: D.STATES_TARGET
            },
            targetItem: {
                router: true,
                one: true,
                required: true,
                reselectable: false,
                states: D.STATES_TARGET
            },
            router: {
                rules: 'path',
                initValue: 'index',
                error: '404'
            },
            navTree: {},
            model: {},
            collection: {},
            tree: {
                empty: '',
                idKey: 'id',
                childKey: 'children'
            },
            nest: {
                empty: '',
                idKey: 'id',
                childKey: 'children'
            }
        };
    })(Options = Pip.Options || (Pip.Options = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Path;
    (function (Path) {
        var G = Globals;
        var PT = G.PipType;
        var ON = G.OptionName;
        var OV = G.OptionValue;
        Path.def = {
            event: function (options) {
                return defineEventPathPart(options);
            },
            eventItem: function (options) {
                return defineEventPathPart(options);
            },
            state: function (options) {
                return defineStatePathPart(options);
            },
            stateItem: function (options) {
                return defineStatePathPart(options);
            },
            template: function (options) {
                return defineTplPathPart(options);
            },
            templateItem: function (options) {
                return defineTplPathPart(options);
            },
            element: function (options) {
                return [];
            },
            shadowElement: function (options) {
                return [];
            },
            listItem: function (options) {
                return [];
            },
            itemElement: function (options) {
                return [];
            },
            sub: function (options) {
                return [PT[PT.sub]];
            },
            list: function (options) {
                return [PT[PT.list]];
            },
            select: function (options) {
                return options[ON[ON.name]]
                    ? [PT[PT.select], options[ON[ON.name]]]
                    : [PT[PT.select]];
            },
            target: function (options) {
                return [PT[PT.target]];
            },
            targetItem: function (options) {
                return [PT[PT.target]];
            },
            router: function (options) {
                return [PT[PT.router]];
            },
            navTree: function (options) {
                return [PT[PT.navTree]];
            },
            model: function (options) {
                return ['models', options[ON[ON.name]] || ObjectId.create()];
            },
            collection: function (options) {
                return ['models', options[ON[ON.name]] || ObjectId.create()];
            },
            tree: function (options) {
                return [PT[PT.tree]];
            },
            nest: function (options) {
                return [PT[PT.nest]];
            }
        };
        function defineTplPathPart(options) {
            var part = [], method;
            var attributeName = options[ON[ON.attr]] || OV[OV.html];
            if (attributeName === OV[OV.html]) {
                method = options[ON[ON.method]] || OV[OV.html];
                part.push(method);
            }
            else if (attributeName === 'class') {
                part = part.concat(['classes', '_tpl']);
            }
            else {
                part.push(attributeName);
            }
            return part;
        }
        function defineStatePathPart(options) {
            var part = [], defaultState;
            if (options[ON[ON.default]]) {
                defaultState = options[ON[ON.default]];
            }
            else {
                defaultState = options[ON[ON.states]][0][ON[ON.name]];
            }
            return part.concat(['states', defaultState]);
        }
        function defineEventPathPart(options) {
            return ['events', Utils.mergeTermsCamelCase(options[ON[ON.events]])];
        }
    })(Path = Pip.Path || (Pip.Path = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Props;
    (function (Props) {
        var G = Globals;
        var PT = G.PipType;
        var ACT = G.Action;
        var ON = G.OptionName;
        var AK = G.AddressKey;
        var PC = G.PipClass;
        var basicProps = function (address) {
            return {
                outActions: Pip.Actions.DOM,
                regActions: Pip.Actions.DOMReg,
                emptyInput: Pip.Input.defineInit(ACT[ACT.remove]),
                emitTest: Pip.Tests.DOMEmit(address)
            };
        };
        Props.singleProps = function (address) {
            return R.merge(basicProps(address), {
                itType: false,
                initReg: null,
                setReg: Pip.SetReg.basic,
                interpret: Pip.Interpret.base,
                diffTest: Pip.Tests.basicDiff
            });
        };
        Props.itemProps = function (address) {
            return R.merge(basicProps(address), {
                itType: true,
                initReg: {},
                setReg: Pip.SetReg.item,
                diffTest: Pip.Tests.objectDiff,
                interpret: Pip.Interpret.item,
                defineItemId: Pip.ItemId.map
            });
        };
        var pipClassProps = {
            event: function (options, address, itType, storage) {
                return {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.enable],
                    values: Pip.Values.event(options, itType),
                    pipFn: Pip.Effect.eventDOMFunctions(options, address, storage),
                    switchFn: Pip.Effect.eventSwitchFn(options[ON[ON.type]], options[ON[ON.delegation]])
                };
            },
            state: function (options, address, itType) {
                return {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.state],
                    values: Pip.Values.state(options, itType),
                    switchFn: Pip.Effect.DOMSwitchFn(),
                    pipFn: Pip.Effect.stateDOMFn(options)
                };
            },
            template: function (options, address, itType) {
                return {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.tpl],
                    values: Pip.Values.template(options, itType),
                    switchFn: Pip.Effect.DOMSwitchFn(),
                    pipFn: Pip.Effect.templateDOMFn(options)
                };
            },
            selectAlike: function (options, address) {
                return {
                    pipType: options[ON[ON.type]],
                    pipClass: options[ON[ON.type]] === PT[PT.select] ? PC[PC.select] : PC[PC.target],
                    initReg: [],
                    setReg: Pip.SetReg.array,
                    values: Pip.Values.select,
                    regActions: Pip.Actions.DOM,
                    diffTest: Pip.Tests.arrayDiff,
                    interpret: Pip.Interpret.correct,
                    correctInput: {
                        define: Pip.Input.correctSelection(options),
                        baseActionTest: Pip.Input.DOMTest,
                        emptyActionTest: Pip.Input.falseTest
                    }
                };
            },
            regPipBasics: function (options, address, itType, storage) {
                var regProps = {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.el],
                    values: Pip.Values.element(options, address, itType, storage),
                    outActions: Pip.Actions.basic,
                    regActions: Pip.Actions.basic,
                    diffTest: Pip.Tests.elDiff
                };
                if (itType) {
                    regProps.publicFn = {
                        getItemId: Pip.Public.getItemId(address, storage)
                    };
                }
                return regProps;
            },
            modelBasic: function (options, address, itType, storage) {
                var pipProps = {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.attr],
                    values: Pip.Values.model(options, itType),
                    outActions: Pip.Actions.model,
                    regActions: Pip.Actions.model,
                    diffTest: Pip.Tests.modelDiff,
                    emitTest: Pip.Tests.modelEmit
                };
                if (options[ON[ON.server]] == null || options[ON[ON.server]] === true) {
                    var server = new ServerLocal.Server(Globals.serverAddress, options[ON[ON.name]], options);
                    var serverIO = new ServerIO.Server(server, options[ON[ON.name]]);
                    pipProps.switchFn = Pip.Effect.modelSwitchFn();
                    pipProps.pipFn = Pip.Effect.serverFn(options, serverIO, address, storage);
                    pipProps.server = serverIO;
                    pipProps.publicFn = {
                        server: serverIO,
                        normalizeServerOutput: Pip.Public.normalizeServerOutput(itType)
                    };
                }
                return pipProps;
            }
        };
        Props.def = {
            'model': function (options, address, storage) {
                var modelProps = pipClassProps.modelBasic(options, address, false, storage);
                modelProps.emptyInput = Pip.Input.defineModelInit(options);
                return R.merge(Props.singleProps(address), modelProps);
            },
            'collection': function (options, address, storage) {
                var collectionProps = R.merge(pipClassProps.modelBasic(options, address, true, storage), {
                    emptyInput: Pip.Input.defineCollectionInit(options),
                    defineItemId: Pip.ItemId.getMid
                });
                return R.merge(Props.itemProps(address), collectionProps);
            },
            'event': function (options, address, storage) {
                return R.merge(Props.singleProps(address), pipClassProps.event(options, address, false, storage));
            },
            'eventItem': function (options, address, storage) {
                var eventItemProps;
                if (options[ON[ON.delegation]]) {
                    var delegatedProps = R.merge(pipClassProps.event(options, address, false, storage), { defineItemId: Pip.ItemId.map });
                    eventItemProps = R.merge(Props.singleProps(address), delegatedProps);
                }
                else {
                    var unDelegatedProps = R.merge(pipClassProps.event(options, address, true, storage), {
                        initReg: [],
                        setReg: Pip.SetReg.array,
                        diffTest: Pip.Tests.arrayDiff
                    });
                    eventItemProps = R.merge(Props.itemProps(address), unDelegatedProps);
                }
                return eventItemProps;
            },
            'state': function (options, address) {
                return R.merge(Props.singleProps(address), pipClassProps.state(options, address, false));
            },
            'stateItem': function (options, address) {
                return R.merge(Props.itemProps(address), pipClassProps.state(options, address, true));
            },
            'template': function (options, address) {
                return R.merge(Props.singleProps(address), pipClassProps.template(options, address, false));
            },
            'templateItem': function (options, address) {
                return R.merge(Props.itemProps(address), pipClassProps.template(options, address, true));
            },
            'select': function (options, address) {
                return R.merge(Props.itemProps(address), pipClassProps.selectAlike(options, address));
            },
            'sub': function (options, address, storage) {
                return R.merge(Props.singleProps(address), {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.sub],
                    values: Pip.Values.node(false),
                    outActions: Pip.Actions.node,
                    regActions: Pip.Actions.nodeReg,
                    pipFn: Pip.Effect.nodeDOMFunctions(options, storage),
                    switchFn: Pip.Effect.subSwitchFn(address)
                });
            },
            'list': function (options, address, storage) {
                return R.merge(Props.itemProps(address), {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.list],
                    defineItemId: Pip.ItemId.node(options),
                    initReg: [],
                    setReg: Pip.SetReg.array,
                    values: Pip.Values.node(true),
                    outActions: Pip.Actions.node,
                    regActions: Pip.Actions.nodeReg,
                    diffTest: Pip.Tests.listDiff,
                    emptyInput: Pip.Input.defineInit(ACT[ACT.delete]),
                    pipFn: Pip.Effect.nodeDOMFunctions(options, storage, address, true),
                    switchFn: Pip.Effect.listSwitchFn(address),
                    interpret: Pip.Interpret.correct,
                    correctInput: {
                        define: Pip.Input.correctList(options),
                        baseActionTest: Pip.Input.insertTest,
                        emptyActionTest: Pip.Input.destructTest
                    },
                    publicFn: {
                        defineItemId: Pip.ItemId.node(options)
                    }
                });
            },
            'element': function (options, address, storage) {
                var elementProps = pipClassProps.regPipBasics(options, address, false, storage);
                elementProps.emptyInput = address[AK[AK.anc]]
                    ? Pip.Input.defineInit(ACT[ACT.remove])
                    : Pip.Input.defineInit(ACT[ACT.insert]);
                return R.merge(Props.singleProps(address), elementProps);
            },
            'shadowElement': function (options, address, storage) {
                var shadowElementProps = R.merge(pipClassProps.regPipBasics(options, address, false, storage), {
                    interpret: Pip.Interpret.correct,
                    correctInput: {
                        define: Pip.Input.filterShadow(options, address),
                        baseActionTest: Pip.Input.destructTest,
                        emptyActionTest: Pip.Input.falseTest
                    }
                });
                return R.merge(Props.singleProps(address), shadowElementProps);
            },
            'listItem': function (options, address, storage) {
                var listItemProps = R.merge(pipClassProps.regPipBasics(options, address, true, storage), {
                    correctInput: {
                        define: Pip.Input.initDOMList(options, address, storage),
                        baseActionTest: Pip.Input.insertTest,
                        emptyActionTest: Pip.Input.destructTest
                    },
                    interpret: Pip.Interpret.correct
                });
                return R.merge(Props.itemProps(address), listItemProps);
            },
            'itemElement': function (options, address, storage) {
                return R.merge(Props.itemProps(address), pipClassProps.regPipBasics(options, address, true, storage));
            },
            'target': function (options, address) {
                return R.merge(Props.singleProps(address), {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.target],
                    values: Pip.Values.state(options, false)
                });
            },
            'targetItem': function (options, address) {
                return R.merge(Props.itemProps(address), pipClassProps.selectAlike(options, address));
            },
            'router': function (options, address, storage) {
                return R.merge(Props.itemProps(address), {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.router],
                    values: Pip.Values.router,
                    diffTest: Pip.Tests.modelDiff,
                    emitTest: Pip.Tests.modelEmit,
                    switchFn: Pip.Effect.routerSwitchFn(),
                    pipFn: Pip.Effect.routerFn(options, storage)
                });
            },
            'navTree': function (options) {
                return R.merge(Props.itemProps({}), {
                    pipType: options[ON[ON.type]],
                    pipClass: PC[PC.nav],
                    setReg: Pip.SetReg.navTree,
                    values: Pip.Values.navTree,
                    outActions: Pip.Actions.basic,
                    regActions: Pip.Actions.basic,
                    diffTest: Pip.Tests.navTreeDiff,
                    interpret: Pip.Interpret.correct,
                    emitTest: Pip.Tests.modelEmit,
                    correctInput: {
                        define: Pip.Input.correctNavTree(options),
                        baseActionTest: Pip.Input.falseTest,
                        emptyActionTest: Pip.Input.destructTest
                    }
                });
            }
        };
        function addPipType(pipProps) {
            Props.def[pipProps.pipType] = pipProps;
        }
        Props.addPipType = addPipType;
    })(Props = Pip.Props || (Pip.Props = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Public;
    (function (Public) {
        var G = Globals;
        var PC = G.PipClass;
        var AK = G.AddressKey;
        var MK = G.MessageKey;
        var ACT = G.Action;
        function getInit(address, pipProps, storage) {
            var pipClass = pipProps.pipClass, actions = pipProps.outActions, itType = pipProps.itType;
            var initFunction;
            if (itType) {
                initFunction = function () {
                    var current = storage.get(address[AK[AK.pip]]).unsafeGet();
                    var init;
                    if (R.is(Array, current)) {
                        return R.map(function (itemId) {
                            var obj = {
                                it: itemId,
                                action: pipClass === PC[PC.el] || pipClass === PC[PC.nav]
                                    ? actions({ action: ACT[ACT.insert] })
                                    : actions({ action: ACT[ACT.create] })
                            };
                            obj[MK[MK.value]] = true;
                            return obj;
                        }, current);
                    }
                    else {
                        return R.values(R.mapObjIndexed(function (val, itemId) {
                            var obj = {
                                it: itemId,
                                action: pipClass === PC[PC.el] || pipClass === PC[PC.nav]
                                    ? actions({ action: ACT[ACT.insert] })
                                    : actions({ action: ACT[ACT.create] })
                            };
                            obj[MK[MK.value]] = val;
                            return obj;
                        }, current));
                    }
                };
            }
            else {
                initFunction = function () {
                    var current = storage.get(address[AK[AK.pip]]).unsafeGet();
                    if (current && !((pipClass === PC[PC.attr] || pipClass === PC[PC.tree]) && R.keys(current).length === 0)) {
                        var obj = {
                            action: pipClass === PC[PC.el] || pipClass === PC[PC.nav]
                                ? actions({ action: ACT[ACT.insert] })
                                : actions({ action: ACT[ACT.create] })
                        };
                        obj[MK[MK.value]] = current;
                        return obj;
                    }
                };
            }
            return initFunction;
        }
        Public.getInit = getInit;
        function addBinding(binding) {
            var bindings = this;
            bindings.push({ sub: binding.sub, subPip: binding.subPip, fn: binding.fn });
        }
        Public.addBinding = addBinding;
        function removeBinding(sub) {
            var bindings = this;
            var bindingIndexToRemove = R.findIndex(function (binding) { return binding[sub] !== sub; }, bindings);
            Utils.remove(bindingIndexToRemove, 1, bindings);
        }
        Public.removeBinding = removeBinding;
        function getBindings(sub) {
            var bindings = this;
            return sub !== void 0
                ? R.find(function (binding) { return binding[sub] === sub; }, bindings)
                : bindings;
        }
        Public.getBindings = getBindings;
        function normalizeServerOutput(itType) {
            return function (data) {
                return itType ? data : data[0];
            };
        }
        Public.normalizeServerOutput = normalizeServerOutput;
        function getItemId(address, storage) {
            return function ($item) {
                var it, i = 0;
                var register = storage.get(address[AK[AK.pip]]).unsafeGet();
                var itemIds = R.keys(register);
                while (!it && i < itemIds.length) {
                    var itemId = itemIds[i];
                    if ($item.equals(register[itemId])) {
                        it = itemId;
                    }
                    i++;
                }
                return it;
            };
        }
        Public.getItemId = getItemId;
    })(Public = Pip.Public || (Pip.Public = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var RegPip;
    (function (RegPip) {
        var G = Globals;
        var PT = G.PipType;
        var ON = G.OptionName;
        var AK = G.AddressKey;
        function isValidSelector(selector, analyser) {
            var id = R.head(R.split('>', selector));
            if (R.nthChar(0, id) === '#') {
                return analyser.isValidId(id);
            }
            return true;
        }
        function getSelectorSequence(sel) {
            var match = /.*\((\d+)\)/.exec(sel);
            return match[1];
        }
        function getAncestorSelString(str) {
            var chunks = R.split('>', str);
            return [R.join('>', R.init(chunks)), R.last(chunks)];
        }
        function stripListPathItem(str) {
            var chunks = R.split('>', str);
            return chunks.length > 1
                ? R.join('>', R.init(chunks))
                : str;
        }
        function getGeneralizeSelector(str, analyser, storage) {
            if (R.nthChar(0, str) === '#') {
                str = analyser.getSelectorFromId(str);
            }
            var match = /(.*)(\(\d+\))(.*)/.exec(str);
            if (!match)
                return str;
            var generalStr = match[2] !== ''
                ? "" + match[1] + match[3]
                : str;
            var idSelector = analyser.getIdFromSelector(generalStr);
            return storage.exists(idSelector)
                ? generalStr
                : getGeneralizeSelector(generalStr, analyser, storage);
        }
        function getPathSelector(selector, analyser) {
            return analyser.getSelectorFromId(selector);
        }
        function createShadowElementSpec(anc, selector, sequenceNumber, analyser) {
            var pipId = analyser.useSelectorIds(selector);
            return {
                addresses: {
                    selector: pipId,
                    pip: pipId,
                    sel: ":" + sequenceNumber,
                    anc: analyser.useSelectorIds(anc)
                },
                options: {
                    attr: 'nth',
                    value: ":" + sequenceNumber,
                    type: PT[PT.shadowElement]
                }
            };
        }
        function createElementSpec(anc, selector, analyser) {
            var pipId = analyser.useSelectorIds(selector);
            return {
                addresses: {
                    selector: pipId,
                    pip: pipId,
                    sel: R.last(R.split('>', selector)),
                    anc: analyser.useSelectorIds(anc)
                },
                options: {
                    type: PT[PT.element]
                }
            };
        }
        function assure(options, storage) {
            var selector = Pip.Addresses.defineSelector(options[ON[ON.selector]]);
            if (selector && !this.regAddressBook[selector]) {
                var pipType = options[ON[ON.type]];
                if (!R.contains(pipType, [PT[PT.state], PT[PT.event], PT[PT.eventItem], PT[PT.template],
                    PT[PT.target], PT[PT.targetItem], PT[PT.list], PT[PT.sub]]) ||
                    (pipType === PT[PT.eventItem] && options[ON[ON.delegation]] === false)) {
                    if (storage.exists(selector)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                if (!isValidSelector(selector, this.analyser))
                    throw new Error("Selector " + selector + " does not exist.");
                var pathSelector = getPathSelector(selector, this.analyser);
                var generalizedSelector = getGeneralizeSelector(pathSelector, this.analyser, this.storage);
                var selectorSequence = getSelectorSequence(pathSelector);
                var ancestorSelString = getAncestorSelString(generalizedSelector);
                var ancestorId = this.analyser.getIdFromSelector(ancestorSelString[0]);
                var normalizedSelector = R.join('>', [ancestorId, ancestorSelString[1]]);
                var ancestorPip = storage.get(this.analyser.useSelectorIds(normalizedSelector));
                var ancestorPipType = ancestorPip.getType();
                if (ancestorPipType === PT[PT.listItem]) {
                    var shadowElementSpec = createShadowElementSpec(normalizedSelector, selector, selectorSequence, this.analyser);
                    Pips.create(shadowElementSpec.options, shadowElementSpec.addresses, storage);
                    this.regAddressBook[shadowElementSpec.addresses[AK[AK.pip]]] = shadowElementSpec.addresses;
                }
                else if (ancestorPipType === PT[PT.itemElement]) {
                    var elementSpec = createElementSpec(normalizedSelector, selector, this.analyser);
                    Pips.create(elementSpec.options, elementSpec.addresses, storage);
                    this.regAddressBook[elementSpec.addresses.pip] = elementSpec.addresses;
                    var shadowElementSpec = createShadowElementSpec(stripListPathItem(normalizedSelector), stripListPathItem(pathSelector), selectorSequence, this.analyser);
                    Pips.create(shadowElementSpec.options, shadowElementSpec.addresses, storage);
                    this.regAddressBook[shadowElementSpec.addresses[AK[AK.pip]]] = shadowElementSpec.addresses;
                }
                else {
                    return false;
                }
            }
            return true;
        }
        RegPip.assure = assure;
    })(RegPip = Pip.RegPip || (Pip.RegPip = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var SetReg;
    (function (SetReg) {
        var G = Globals;
        var ACT = G.Action;
        function basic(register, action, value) {
            register.value = value;
        }
        SetReg.basic = basic;
        function item(register, action, value, itemId) {
            if (itemId) {
                if ((action === ACT[ACT.remove]) || (action === ACT[ACT.delete])) {
                    if (register.value[itemId]) {
                        delete register.value[itemId];
                    }
                }
                else {
                    register.value[itemId] = value;
                }
            }
            else {
                register.value = value;
            }
        }
        SetReg.item = item;
        function array(register, action, value, itemId) {
            if (itemId) {
                var idx;
                function findIndex() {
                    var temp = itemId.split(G.MERGETOKEN), id = temp[0];
                    return R.indexOf(id, R.map(function (val) { return val.split(G.MERGETOKEN)[0]; }, register.value));
                }
                switch (action) {
                    case ACT[ACT.create]:
                        if (typeof value === 'number') {
                            Utils.insert(value, itemId, register.value);
                        }
                        else {
                            if (value !== false)
                                register.value.push(itemId);
                        }
                        break;
                    case ACT[ACT.update]:
                        if (typeof value === 'number') {
                            idx = findIndex();
                            if (value !== idx) {
                                Utils.remove(idx, 1, register.value);
                                Utils.insert(value, itemId, register.value);
                            }
                        }
                        else {
                            if (value === false) {
                                idx = findIndex();
                                if (idx !== -1) {
                                    Utils.remove(idx, 1, register.value);
                                }
                            }
                            else {
                                register.value.push(itemId);
                            }
                        }
                        break;
                    case ACT[ACT.delete]:
                        idx = findIndex();
                        if (idx !== -1) {
                            Utils.remove(idx, 1, register.value);
                        }
                        break;
                    default:
                        break;
                }
            }
            else {
                if (action === ACT[ACT.delete]) {
                    register.value = [];
                }
            }
        }
        SetReg.array = array;
        function navTree(register, action, value, itemId) {
            switch (action) {
                case ACT[ACT.remove]:
                    if (register.value[itemId]) {
                        delete register.value[itemId];
                    }
                    break;
                case ACT[ACT.create]:
                    if (!(register.value[itemId])) {
                        register.value[itemId] = { children: [] };
                    }
                    register.value[itemId].children.push(value);
                    break;
                case ACT[ACT.update]:
                    if (register.value[itemId]) {
                        var idx = R.indexOf(value, register.value[itemId].children);
                        if (idx !== -1) {
                            Utils.remove(idx, 1, register.value[itemId].children);
                        }
                    }
                    break;
                default:
                    register.value[itemId] = value;
            }
        }
        SetReg.navTree = navTree;
    })(SetReg = Pip.SetReg || (Pip.SetReg = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Spec;
    (function (Spec) {
        var G = Globals;
        var PT = G.PipType;
        var ON = G.OptionName;
        var AK = G.AddressKey;
        function isMulti(type) {
            return R.contains(type, [PT[PT.stateItem], PT[PT.eventItem], PT[PT.templateItem],
                PT[PT.listItem], PT[PT.itemElement], PT[PT.collection],
                PT[PT.list], PT[PT.select], PT[PT.targetItem],
                PT[PT.router], PT[PT.navTree], PT[PT.nest]]);
        }
        Spec.isMulti = isMulti;
        function definePipId(path, ancestorId) {
            return ancestorId !== void 0
                ? ancestorId + (path.length > 0 ? '.' + R.join('.', path) : '')
                : R.join('.', path);
        }
        function defineSelectStates(options) {
            var pipType = options[ON[ON.type]];
            var isStandardDefined = function (StandardName) {
                return R.containsWith(function (s) { return s.name === StandardName; }, options[ON[ON.states]]);
            };
            var unSelectState = (pipType === PT[PT.select]) ? G.IS_UNSELECTED : G.NO_TARGET;
            var selectState = (pipType === PT[PT.select]) ? G.IS_SELECTED : G.IS_TARGET;
            if (!isStandardDefined(unSelectState) || !isStandardDefined(selectState)) {
                throw new Error('the required stateNames are NOT used within select or target(Item)');
            }
            return {
                selected: selectState,
                unSelected: unSelectState
            };
        }
        Spec.defineSelectStates = defineSelectStates;
        function define(options, regAddressBook) {
            var spec, addresses, ancestorId = Pip.Addresses.defineSelector(options[ON[ON.selector]]), pipType = options[ON[ON.type]], path = Pip.Path.def[pipType](options), pipId = definePipId(path, ancestorId);
            if (ancestorId) {
                switch (pipType) {
                    case PT[PT.list]:
                        addresses = Pip.Addresses.defineListAddresses(options);
                        break;
                    case PT[PT.listItem]:
                        addresses = Pip.Addresses.defineListItemAddresses(options);
                        break;
                    case PT[PT.eventItem]:
                        addresses = Pip.Addresses.defineEventAddresses(options, regAddressBook, true);
                        break;
                    case PT[PT.event]:
                        addresses = Pip.Addresses.defineEventAddresses(options, regAddressBook, false);
                        break;
                    case PT[PT.tree]:
                    case PT[PT.nest]:
                        addresses = Pip.Addresses.defineTreeNestAddresses(options);
                        break;
                    default:
                        addresses = R.assoc(AK[AK.anc], ancestorId, {});
                }
            }
            spec = {
                options: R.merge(Pip.Options.defaults[pipType], options),
                addresses: R.merge({ pip: pipId }, addresses)
            };
            return spec;
        }
        Spec.define = define;
    })(Spec = Pip.Spec || (Pip.Spec = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Tests;
    (function (Tests) {
        var G = Globals;
        var ACT = G.Action;
        var AK = G.AddressKey;
        function objectDiff(desiredValue, register, itemId) {
            return itemId
                ? desiredValue !== register.value[itemId]
                : desiredValue !== register.value;
        }
        Tests.objectDiff = objectDiff;
        function basicDiff(desiredValue, register) {
            return desiredValue !== register.value;
        }
        Tests.basicDiff = basicDiff;
        function elDiff(desiredValue, register, itemId) {
            var storedValue;
            if (itemId) {
                storedValue = register.value[itemId] || {};
            }
            else {
                storedValue = register.value;
            }
            if (R.keys(desiredValue).length === 0 || R.keys(storedValue).length === 0) {
                return true;
            }
            else if (desiredValue.equals(storedValue)) {
                return false;
            }
            else {
                return true;
            }
        }
        Tests.elDiff = elDiff;
        function arrayDiff(desiredValue, register, itemId) {
            if (itemId) {
                return desiredValue !== R.contains(itemId, register.value);
            }
            else {
                return !(desiredValue.length === register.value.length && R.reduce(function (acc, a) { return acc && a; }, true, R.map(function (t) { return t[0] === t[1]; }, R.zip(desiredValue, register.value))));
            }
        }
        Tests.arrayDiff = arrayDiff;
        function listDiff(desiredValue, register, itemId) {
            if (itemId) {
                if (typeof desiredValue === 'boolean') {
                    return desiredValue !== R.contains(itemId, register.value);
                }
                else if (typeof desiredValue === 'number') {
                    return desiredValue !== R.indexOf(itemId, register.value);
                }
                else {
                    throw new Error('Hier mag je niet komen, position wordt verwacht maar niet gegeven');
                }
            }
            else {
                return !(desiredValue.length === register.value.length && R.reduce(function (acc, a) { return acc && a; }, true, R.map(function (t) { return t[0] === t[1]; }, R.zip(desiredValue, register.value))));
            }
        }
        Tests.listDiff = listDiff;
        function modelDiff(desiredValue, register, itemId) {
            var currentModel = itemId ? register.value[itemId] : register.value;
            return !R.equals(desiredValue, currentModel);
        }
        Tests.modelDiff = modelDiff;
        function navTreeDiff(desiredValue, register, itemId) {
            return (typeof desiredValue === 'string')
                ? true
                : modelDiff(desiredValue, register, itemId);
        }
        Tests.navTreeDiff = navTreeDiff;
        function DOMEmit(address) {
            return function (diff, action, empty, $anc) {
                return (diff && (!!$anc ||
                    action === ACT[ACT.remove] ||
                    (empty && ($anc || !address[AK[AK.anc]]))));
            };
        }
        Tests.DOMEmit = DOMEmit;
        function modelEmit(diff) {
            return diff;
        }
        Tests.modelEmit = modelEmit;
    })(Tests = Pip.Tests || (Pip.Tests = {}));
})(Pip || (Pip = {}));

var Pip;
(function (Pip) {
    var Values;
    (function (Values) {
        var G = Globals;
        var MK = G.MessageKey;
        var ON = G.OptionName;
        var AK = G.AddressKey;
        var PT = G.PipType;
        Values.arrayInsertValue = function (pipIn, register, defaultValue, itemId) {
            return R.contains(itemId, register.value);
        };
        Values.justValueIn = function (pipIn) {
            return pipIn[MK[MK.value]];
        };
        Values.itemInsertValue = function (pipIn, register, defaultValue, itemId) {
            return register.value[itemId]
                ? register.value[itemId]
                : defaultValue;
        };
        Values.basicInsertValue = function (pipIn, register, defaultValue) {
            return register.value
                ? register.value
                : defaultValue;
        };
        Values.select = {
            update: Values.justValueIn,
            defaultValue: function () { return false; },
            reg: function () { return []; },
            insert: Values.arrayInsertValue
        };
        Values.router = {
            update: Values.justValueIn,
            insert: Values.itemInsertValue,
            defaultValue: function () { active: false; },
            reg: function () { return {}; }
        };
        Values.navTree = {
            create: Values.justValueIn,
            update: Values.justValueIn,
            insert: function (pipIn, register, defaultValue, itemId) {
                return defaultValue;
            },
            defaultValue: function () { return { children: [] }; },
            reg: function () { return {}; }
        };
        function node(itType) {
            function insertFn(pipIn, register, defaultValue) {
                return register.value || defaultValue;
            }
            function createFn(pipIn) {
                if (R.contains(G.POS, R.keys(pipIn.value))) {
                    return pipIn.value[G.POS];
                }
                else {
                    return true;
                }
            }
            return {
                create: createFn,
                update: createFn,
                defaultValue: function () { return false; },
                insert: Values.basicInsertValue,
                reg: function () { return itType ? [] : false; }
            };
        }
        Values.node = node;
        function element(options, address, itType, storage) {
            var pipType = options[ON[ON.type]];
            var defineEl;
            switch (pipType) {
                case PT[PT.listItem]:
                    defineEl = function ($el) {
                        return $el;
                    };
                    break;
                case PT[PT.itemElement]:
                    defineEl = function ($ancestor, itemId) {
                        $ancestor = $ancestor;
                        return DOMIO.createScoped($ancestor, address[AK[AK.sel]]);
                    };
                    break;
                case PT[PT.shadowElement]:
                    defineEl = function ($ancestor) {
                        $ancestor = $ancestor;
                        return $ancestor;
                    };
                    break;
                default:
                    if (address[AK[AK.anc]]) {
                        defineEl = function ($ancestor) {
                            $ancestor = $ancestor || storage.get(address[AK[AK.anc]]).get();
                            return DOMIO.createScoped($ancestor, address[AK[AK.sel]]);
                        };
                    }
                    else {
                        defineEl = function () {
                            return DOMIO.create(address[AK[AK.selector]]);
                        };
                    }
            }
            return {
                defaultValue: function () { return itType ? {} : null; },
                insert: function (pipIn, register, defaultValue, itemId) {
                    return defineEl(pipIn[MK[MK.value]], itemId);
                },
                reg: function () { return itType ? {} : null; }
            };
        }
        Values.element = element;
        function model(options, itType) {
            // return itType ? defaultModels : defaultModels[0];
            var update = itType
                ? function (pipIn, register, itemId) {
                    return pipIn[MK[MK.value]];
                }
                : function (pipIn, register) {
                    return pipIn[MK[MK.value]];
                };
            return {
                defaultValue: function () { },
                create: Values.justValueIn,
                update: update,
                reg: function () { return {}; }
            };
        }
        Values.model = model;
        function event(options, itType) {
            function defaultEventValue(options) {
                return options[ON[ON.enable]] === undefined || options[ON[ON.enable]] === true
                    ? true
                    : false;
            }
            function defaultEventReg(options, itType) {
                return (itType)
                    ? []
                    : defaultEventValue(options);
            }
            function eventInsertValue(options, itType) {
                if (itType) {
                    return function (pipIn, register, defaultValue, itemId) {
                        return R.contains(itemId, register.value) || defaultValue;
                    };
                }
                else {
                    return function (pipIn, register, defaultValue) {
                        return register.value || defaultValue;
                    };
                }
            }
            var desiredVals = {
                create: Values.justValueIn,
                update: Values.justValueIn,
                defaultValue: function () { return defaultEventValue(options); },
                reg: function () { return defaultEventReg(options, itType); },
                insert: eventInsertValue(options, itType)
            };
            return desiredVals;
        }
        Values.event = event;
        function defaultState(options) {
            var states = options[ON[ON.states]];
            var pipType = options[ON[ON.type]];
            var defaultState = options[ON[ON.default]];
            if (!defaultState) {
                switch (pipType) {
                    case PT[PT.select]:
                        defaultState = G.IS_UNSELECTED;
                        break;
                    case PT[PT.target]:
                    case PT[PT.targetItem]:
                        defaultState = G.NO_TARGET;
                        break;
                    default:
                        defaultState = states[0].name
                            ? states[0].name
                            : states[0].value;
                }
            }
            return defaultState;
        }
        Values.defaultState = defaultState;
        function otherToggleState(state, options) {
            var states = options[ON[ON.states]], firstName = states[0].name || states[0].value, stateIndex = firstName === state ? 0 : 1, otherIndex = stateIndex === 0 ? 1 : 0, otherState = states[otherIndex].name || states[otherIndex].value;
            return otherState;
        }
        Values.otherToggleState = otherToggleState;
        function state(options, itType) {
            var desiredVals = {
                create: Values.justValueIn,
                update: Values.justValueIn,
                defaultValue: function () { return defaultState(options); },
                reg: function () { return itType ? {} : defaultState(options); },
                insert: itType ? Values.itemInsertValue : Values.basicInsertValue
            };
            return desiredVals;
        }
        Values.state = state;
        function template(options, itType) {
            function defaultTemplateValue(options) {
                return options[ON[ON.empty]] || '';
            }
            var desiredVals = {
                create: Values.justValueIn,
                update: Values.justValueIn,
                defaultValue: function () { return defaultTemplateValue(options); },
                reg: function () { return itType ? {} : defaultTemplateValue(options); },
                insert: itType ? Values.itemInsertValue : Values.basicInsertValue
            };
            return desiredVals;
        }
        Values.template = template;
    })(Values = Pip.Values || (Pip.Values = {}));
})(Pip || (Pip = {}));

var Pips;
(function (Pips) {
    var G = Globals;
    var PT = G.PipType;
    var ON = G.OptionName;
    var AK = G.AddressKey;
    var MK = G.MessageKey;
    var ACT = G.Action;
    var LO = G.LinkOptionName;
    function init(address, pipProps, storage) {
        var register = { value: pipProps.initReg };
        var links = [];
        var linkSources;
        var bindingSources;
        var interpret = pipProps.interpret(address, pipProps, storage);
        var public_ = {
            getInit: Pip.Public.getInit(address, pipProps, storage)
        };
        if (pipProps.pipClass === PC[PC.enable] || pipProps.server) {
            var bindings = [];
            public_ = R.merge(public_, {
                addBinding: function (binding) { return Pip.Public.addBinding.call(bindings, binding); },
                removeBinding: function (binding) { return Pip.Public.removeBinding.call(bindings, binding); },
                getBindings: function () { return Pip.Public.getBindings.call(bindings); }
            });
        }
        if (pipProps.pipClass === PC[PC.attr]) {
            public_.resend = function () {
                return emit(R.map(function (m) {
                    return {
                        it: m[G.IT],
                        value: m,
                        action: ACT[ACT.update],
                        emit: false
                    };
                }, get()));
            };
        }
        if (pipProps.publicFn) {
            R.forEach(function (pfn) { return public_[pfn] = pipProps.publicFn[pfn]; }, R.keys(pipProps.publicFn));
        }
        function emit(pipOut) {
            R.forEach(function (link) {
                // console.log(pipProps.pipType, Array.isArray(pipOut)
                //     ? "["+pipOut[0].action+"]"
                //     : pipOut.action, link.sub);
                var linkOut = link.fn(pipOut);
                if (linkOut) {
                    if (!R.is(Array, linkOut) || linkOut.length !== 0) {
                        var subPip = link.subPip;
                        subPip.react(linkOut);
                    }
                }
            }, links);
        }
        function act(result) {
            function correctPipOut(pipOut, result) {
                if (pipOut instanceof Array) {
                    if (result instanceof Array) {
                        var out = R.reduce(function (acc, combi) {
                            if (combi[1].emit !== false) {
                                acc.push(combi[0]);
                            }
                            return acc;
                        }, [], R.zip(pipOut, result));
                        if (out.length > 0)
                            return out;
                    }
                    else {
                        if (result.emit !== false) {
                            return pipOut;
                        }
                    }
                }
                else {
                    if (result.emit !== false) {
                        if (pipOut) {
                            return pipOut;
                        }
                        else {
                            return result.pipOut;
                        }
                    }
                }
            }
            function evaluateRegister(result) {
                if (result instanceof Array && result.length !== 0) {
                    R.forEach(function (res) {
                        if (res.reg) {
                            res.reg.mutator(register, res.reg.action, res.reg.desiredValue, res.reg.itemId);
                        }
                    }, result);
                }
                else {
                    var res = result;
                    if (res.reg) {
                        res.reg.mutator(register, res.reg.action, res.reg.desiredValue, res.reg.itemId);
                    }
                }
            }
            function evaluateEffects(result) {
                var effectSwitcher = pipProps.switchFn;
                var pipOut;
                if (effectSwitcher) {
                    pipOut = effectSwitcher(result, register);
                }
                else {
                    pipOut = (result instanceof Array)
                        ? R.pluck('pipOut', result)
                        : result.pipOut;
                }
                if (pipOut)
                    return correctPipOut(pipOut, result);
            }
            if (result != null) {
                evaluateRegister(result);
                var pipOut = evaluateEffects(result);
                if (pipOut) {
                    if (!R.is(Array, pipOut) || pipOut.length > 0) {
                        emit(pipOut);
                    }
                }
            }
        }
        function react(pipIn) {
            act(interpret(pipIn, register));
        }
        function unsafeGet(id) {
            return id != null
                ? register.value[id]
                : register.value;
        }
        function get(id) {
            if (pipProps.pipType === PT[PT.collection] || pipProps.pipType === PT[PT.navTree])
                return id != null
                    ? R.assoc(G.IT, id, R.clone(register.value[id]))
                    : R.values(R.mapObjIndexed(function (value, key) {
                        return R.assoc(G.IT, key, value);
                    }, R.clone(register.value)));
            else
                return id != null
                    ? R.clone(register.value[id])
                    : R.clone(register.value);
        }
        function getType() {
            return pipProps.pipType;
        }
        function addLink(link) {
            links.push(link);
        }
        function addLinks(ls) {
            links = R.concat(ls, links);
        }
        function removeLink(sub) {
            links = R.filter(function (link) { return link.sub !== sub; }, links);
        }
        function getLinks(sub) {
            return sub != null
                ? R.find(function (link) { return link.sub === sub; }, links)
                : links;
        }
        function getLinkSources() {
            return linkSources;
        }
        function addLinkSource(pubPipId) {
            linkSources.push(pubPipId);
        }
        function removeLinkSource(pubPipId) {
            linkSources = R.filter(function (lSource) { return lSource !== pubPipId; }, linkSources);
        }
        function getBindingSources() {
            return bindingSources;
        }
        function addBindingSource(pubPipId) {
            bindingSources.push(pubPipId);
        }
        function removeBindingSource(pubPipId) {
            bindingSources = R.filter(function (bSource) { return bSource !== pubPipId; }, bindingSources);
        }
        var returnObject = R.merge(public_, {
            react: react,
            getType: getType,
            get: get,
            unsafeGet: unsafeGet,
            addLink: addLink,
            getLinks: getLinks,
            addLinks: addLinks,
            removeLink: removeLink,
            getLinkSources: getLinkSources,
            addLinkSource: addLinkSource,
            removeLinkSource: removeLinkSource,
            getBindingSources: getBindingSources,
            addBindingSource: addBindingSource,
            removeBindingSource: removeBindingSource
        });
        return returnObject;
    }
    function create(options, address, storage) {
        var pipType = options[ON[ON.type]];
        var pipProps = Pip.Props.def[pipType](options, address, storage);
        var pipClass = pipProps.pipClass;
        var thisPip = init(address, pipProps, storage);
        storage.set(address[AK[AK.pip]], thisPip);
        var initInput = (pipProps.pipClass === PC[PC.attr])
            ? pipProps.emptyInput
            : R.merge(pipProps.emptyInput, { init: true });
        thisPip.react(initInput);
        if (address[AK[AK.anc]]) {
            var linkOptions = {};
            linkOptions[LO[LO.pub]] = address[AK[AK.anc]];
            linkOptions[LO[LO.sub]] = address[AK[AK.pip]];
            if (options[LO[LO.refine]])
                linkOptions[LO[LO.refine]] = options[LO[LO.refine]];
            Links.create(linkOptions, storage);
        }
        else if (pipClass === PC[PC.attr] && options[ON[ON.server]] === true) {
            thisPip.server.fetch()
                .map(function (result) {
                var data = [];
                R.forEach(function (key) {
                    var out = {};
                    out[MK[MK.it]] = key;
                    out[MK[MK.action]] = ACT[ACT.create];
                    out[MK[MK.value]] = result[key];
                    data.push(out);
                }, R.keys(result));
                return data;
            })
                .fork(function (err) { throw new Error(err); }, function (data) { return thisPip.react(thisPip.normalizeServerOutput(data)); });
        }
    }
    Pips.create = create;
    function remove(pipId, storage) {
        var pip = storage.get(pipId);
        var pipType = pip.getType();
        var resetAction = pipType === PT[PT.collection] || pipType === PT[PT.model]
            ? ACT[ACT.delete]
            : ACT[ACT.remove];
        pip.react({ action: resetAction });
        storage.remove(pipId);
    }
    Pips.remove = remove;
})(Pips || (Pips = {}));

/*
 * #Routing
 *
 * Binds select pip states to the url and allows url changes to change select pips.
 * The url is used to initiaze an application
 *
 */
var Routing;
(function (Routing) {
    function navigation(changes, options) {
        var source = options.source || '', target = options.target;
        this.execute(target + ':navigate', changes, options);
        this.lookForFollowUp('navigate', target, changes, options);
        var allMenus = Globals.navTree[target], menu;
        if (source === 'url' || source === 'initialize' || source === '') {
            for (menu in allMenus) {
                this.execute(allMenus[menu] + ':navigate', changes, options);
            }
        }
        else {
            var otherMenus = R.difference(allMenus, [source]);
            for (menu in otherMenus) {
                this.execute(otherMenus[menu] + ':navigate', changes, options);
            }
        }
    }
    Routing.navigation = navigation;
})(Routing || (Routing = {}));

var ServerAJAX;
(function (ServerAJAX) {
    var Future = Monads.Future;
    var Server = (function () {
        function Server(url, collection, options) {
            this.url = url;
            this.collection = collection;
            this.index = options && options.index ? options.index : void 0;
        }
        Server.prototype.emit = function (serverActions, callback) {
            var _this = this;
            if (typeof serverActions === 'string') {
                if (serverActions === 'fetch')
                    this.fetchData(callback);
            }
            else {
                var methods = R.keys(serverActions);
                var methodsWithData = R.filter(function (method) { return serverActions[method].length > 0; }, methods);
                var futures = [];
                R.forEach(function (method) {
                    var data = serverActions[method];
                    switch (method) {
                        case 'create':
                            futures.push(_this.createItems(data));
                            break;
                        case 'update':
                            futures.push(_this.updateItems(data));
                            break;
                        case 'delete':
                            futures.push(_this.deleteItems(data));
                            break;
                        case 'empty':
                            futures.push(_this.deleteAllItems());
                            break;
                    }
                }, methodsWithData);
                var future = R.commute(Future.of, futures);
                future.fork(function (err) {
                    return callback(err);
                }, function (data) {
                    return callback(null, data);
                });
            }
        };
        Server.prototype.createItems = function (data) {
            var _this = this;
            var future = new Future(function (reject, resolve) {
                var augmentedData = [];
                if (_this.index) {
                    R.forEach(function (item) {
                        item[_this.index] = ObjectId.create();
                        item[Globals.IT] = item.it;
                        augmentedData.push(item);
                    }, data);
                }
                else {
                    augmentedData = data;
                }
                $.ajax(_this.url + "/" + _this.collection + "/create", augmentedData)
                    .done(function (result, textStatus, jqXHR) {
                    resolve(result);
                })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                    reject(errorThrown);
                });
            });
            return future;
        };
        Server.prototype.updateItems = function (data) {
            var _this = this;
            var future = new Future(function (reject, resolve) {
                $.ajax(_this.url + "/" + _this.collection + "/update", data)
                    .done(function (result, textStatus, jqXHR) {
                    resolve(result);
                })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                    reject(errorThrown);
                });
            });
            return future;
        };
        Server.prototype.deleteItems = function (data) {
            var _this = this;
            var future = new Future(function (reject, resolve) {
                $.ajax(_this.url + "/" + _this.collection + "/delete", data)
                    .done(function (result, textStatus, jqXHR) {
                    resolve(result);
                })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                    reject(errorThrown);
                });
            });
            return future;
        };
        Server.prototype.deleteAllItems = function () {
            var _this = this;
            var future = new Future(function (reject, resolve) {
                $.ajax(_this.url + "/" + _this.collection + "/deleteAll")
                    .done(function (result, textStatus, jqXHR) {
                    resolve(result);
                })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                    reject(errorThrown);
                });
            });
            return future;
        };
        Server.prototype.fetchData = function (cb) {
            $.ajax(this.url + "/" + this.collection + "/fetch")
                .done(function (result, textStatus, jqXHR) {
                cb(null, result);
            })
                .fail(function (jqXHR, textStatus, errorThrown) {
                cb(errorThrown);
            });
        };
        return Server;
    })();
    ServerAJAX.Server = Server;
})(ServerAJAX || (ServerAJAX = {}));

var ServerIO;
(function (ServerIO) {
    var Future = Monads.Future;
    var Server = (function () {
        function Server(dispatchServer, collectionName, options) {
            this._server = dispatchServer;
        }
        Server.prototype.collectActions = function (servActions) {
            var collected = {
                create: [],
                update: [],
                'delete': [],
                empty: []
            };
            R.forEach(function (servAct) {
                var method = servAct[0], data = servAct[1];
                collected[method].push(data);
            }, servActions);
            return collected;
        };
        Server.prototype.sync = function (servActions) {
            var _this = this;
            return new Future(function (reject, resolve) {
                _this._server.emit(_this.collectActions(servActions), function (err, data) {
                    return (err)
                        ? reject(err)
                        : resolve(data);
                });
            });
        };
        Server.prototype.fetch = function () {
            var _this = this;
            return new Future(function (reject, resolve) {
                _this._server.emit('fetch', function (err, data) {
                    return (err)
                        ? reject(err)
                        : resolve(data);
                });
            });
        };
        return Server;
    })();
    ServerIO.Server = Server;
})(ServerIO || (ServerIO = {}));

var ServerLocal;
(function (ServerLocal) {
    var Server = (function () {
        function Server(serverAddress, collection, options) {
            if (!window.localStorage)
                throw new Error('The browser does not support localStorage');
            this.collection = collection;
            this.index = options && options.index ? options.index : void 0;
        }
        Server.prototype.emit = function (serverActions, callback) {
            var _this = this;
            if (typeof serverActions === 'string') {
                if (serverActions === 'fetch')
                    this.fetchData(callback);
            }
            else {
                var methods = R.keys(serverActions);
                var methodsWithData = R.filter(function (method) { return serverActions[method].length > 0; }, methods);
                R.forEach(function (method) {
                    var data = serverActions[method];
                    switch (method) {
                        case 'create':
                            _this.createItems(data);
                            break;
                        case 'update':
                            _this.updateItems(data);
                            break;
                        case 'delete':
                            _this.deleteItems(data);
                            break;
                        case 'empty':
                            _this.deleteAllItems();
                            break;
                    }
                }, methodsWithData);
                callback(null);
            }
        };
        Server.prototype.createItems = function (data) {
            var _this = this;
            R.forEach(function (item) {
                var key = item.it;
                window.localStorage.setItem(_this.collection + '.' + key, JSON.stringify(item.value));
            }, data);
        };
        Server.prototype.updateItems = function (data) {
            var _this = this;
            R.forEach(function (item) {
                var key = item.it;
                window.localStorage.setItem(_this.collection + '.' + key, JSON.stringify(item.value));
            }, data);
        };
        Server.prototype.deleteItems = function (data) {
            var _this = this;
            R.forEach(function (item) {
                window.localStorage.removeItem(_this.collection + '.' + item.it);
            }, data);
        };
        Server.prototype.deleteAllItems = function () {
            var _this = this;
            var dataKeys = this.getCollectionKeys();
            R.forEach(function (key) {
                window.localStorage.removeItem(_this.collection + '.' + key);
            }, dataKeys);
        };
        Server.prototype.getCollectionKeys = function () {
            var _this = this;
            return R.filter(function (key) { return _this.collection === R.slice(0, _this.collection.length, key); }, R.keys(window.localStorage));
        };
        Server.prototype.fetchData = function (cb) {
            var _this = this;
            var dataKeys = this.getCollectionKeys();
            if (dataKeys.length > 0) {
                var data = {};
                R.forEach(function (item) {
                    var key = R.slice(_this.collection.length + 1, Infinity, item);
                    data[key] = JSON.parse(window.localStorage[item]);
                }, dataKeys);
                cb(null, data);
            }
            else {
                cb(null, {});
            }
        };
        return Server;
    })();
    ServerLocal.Server = Server;
})(ServerLocal || (ServerLocal = {}));

var Store;
(function (Store) {
    var mergeTerms = Utils.mergeTermsCamelCase;
    function Storage() {
        var store = {};
        var idCounter = 0;
        function splitter(address) {
            var len = address.length;
            var matches = [];
            var p = 0, word = '';
            var start = true;
            while (p < len) {
                if (address[p] !== '.') {
                    word += address[p];
                    start = false;
                }
                else {
                    if (start) {
                        word += address[p];
                        start = false;
                    }
                    else {
                        matches.push(mergeTerms(word));
                        word = '';
                        start = true;
                    }
                }
                p++;
            }
            matches.push(mergeTerms(word));
            return matches;
        }
        function extend(st, chunks) {
            var ad = chunks.shift();
            if (ad) {
                st[ad] = st[ad] || {};
                extend(st[ad], chunks);
            }
        }
        function save(chunks, pl) {
            var ref = store;
            var len = chunks.length;
            for (var i = 0; i < len - 1; i++) {
                ref = ref[chunks[i]];
            }
            ref[chunks[i]].__pip = pl;
        }
        function set(address, pip) {
            if (!address || address.length === 0 || !pip)
                throw new TypeError('Arguments do not match specification');
            var splitAddress = splitter(address);
            extend(store, R.clone(splitAddress));
            save(splitAddress, pip);
        }
        function get(address) {
            var ref = pathToPip(address);
            return ref ? ref['__pip'] : null;
        }
        function remove(address) {
            var ref = pathToPip(address);
            if (ref)
                delete ref['__pip'];
        }
        function pathToPip(address) {
            if (!address)
                return;
            var chunks = splitter(address);
            var ref = store;
            var len = chunks.length;
            var i = 0;
            while (i < len) {
                if (!ref[chunks[i]])
                    return null;
                ref = ref[chunks[i]];
                i++;
            }
            return ref;
        }
        function exists(address) {
            return get(address) != null;
        }
        var returnObj = {
            set: set,
            get: get,
            exists: exists,
            remove: remove
        };
        returnObj.getAll = function () {
            return store;
        };
        returnObj.getAllLinks = function () {
            function show(type, links) {
                R.forEach(function (link) {
                    console.log('pub: ' + type + ', sub: ' + link.sub);
                }, links);
            }
            function getPips(st) {
                R.mapObjIndexed(function (val, key, obj) {
                    if (key === '__pip')
                        show(val.getType(), val.getLinks());
                    if (R.is(Object, val))
                        getPips(val);
                }, st);
            }
            getPips(store);
        };
        return returnObj;
    }
    Store.Storage = Storage;
})(Store || (Store = {}));

var Tree;
(function (Tree) {
    var Flatten;
    (function (Flatten) {
        var G = Globals;
        var PT = G.PipType;
        var RPT = G.RegPipType;
        var ACT = G.Action;
        var AK = G.AddressKey;
        function flatten(tagSpec, nodeId, rootId) {
            var _this = this;
            var regPipNames = [PT[PT.element], PT[PT.listItem], PT[PT.itemElement], PT[PT.shadowElement]];
            var appEl;
            if (this.virtualDOM) {
                var returnPath = function (memberElement) {
                    if (memberElement && memberElement.path) {
                        return memberElement.path;
                    }
                };
                var extractAppel = function (tagSpecKey) {
                    if (tagSpecKey === 'children') {
                        return R.map(returnPath, tagSpec.children);
                    }
                    else if (tagSpecKey === 'parent') {
                        returnPath(tagSpec.parent);
                    }
                    else if (!R.contains(tagSpecKey, regPipNames)) {
                        return tagSpec[tagSpecKey];
                    }
                };
                appEl = R.mapObj(extractAppel, tagSpec);
            }
            R.forEach(function (regPipName) {
                if (tagSpec[regPipName]) {
                    var regType = regPipName, options = { type: regType }, address = tagSpec[regType], regPipId = address[AK[AK.selector]];
                    address[AK[AK.pip]] = regPipId;
                    if (nodeId) {
                        address[AK[AK.anc]] = nodeId;
                    }
                    if (_this.storage.exists(regPipId)) {
                        if (nodeId) {
                            _this.replacePip(options, address);
                        }
                    }
                    else {
                        if (_this.virtualDOM) {
                            appEl[regPipName] = regPipId;
                        }
                        Pips.create(options, address, _this.storage);
                        var parentId = (regPipName === PT[PT.itemElement])
                            ? tagSpec[regPipName].item
                            : tagSpec[regPipName].anc;
                        if (_this.navTree.length > 0) {
                            var parentModel = R.find(function (navModel) { return R.propEq('id', parentId, navModel); }, _this.navTree);
                            if (parentModel) {
                                parentModel.children.push(regPipId);
                            }
                        }
                        var navModel = {
                            id: regPipId,
                            type: RPT[RPT[regPipName]],
                            parent: parentId,
                            children: []
                        };
                        _this.navTree.push(navModel);
                    }
                    _this.regAddressBook[regPipId] = R.assoc(AK[AK.pip], address[AK[AK.pip]], {});
                    _this.regAddressBook[regPipId][AK[AK.anc]] = address[AK[AK.anc]];
                    if (regType === PT[PT.listItem] || regType === PT[PT.itemElement]) {
                        _this.regAddressBook[regPipId][AK[AK.root]] = address[AK[AK.root]];
                        _this.regAddressBook[regPipId][AK[AK.sel]] = address[AK[AK.sel]];
                        if (regType === PT[PT.listItem]) {
                            _this.regAddressBook[regPipId][AK[AK.item]] = address[AK[AK.pip]];
                        }
                        else {
                            _this.regAddressBook[regPipId][AK[AK.item]] = address[AK[AK.item]];
                        }
                    }
                }
            }, regPipNames);
            if (tagSpec.children.length > 0) {
                R.forEach(function (c) { return flatten.call(_this, c); }, tagSpec.children);
            }
            if (this.virtualDOM) {
                this.virtualDOM.react({
                    value: appEl,
                    it: appEl.path,
                    action: ACT[ACT.create]
                });
            }
        }
        function flattenTree(treeSpec, nodeId, rootId) {
            var _this = this;
            if (treeSpec.length === 0)
                return;
            R.forEach(function (c) { return flatten.call(_this, c, nodeId, rootId); }, treeSpec);
        }
        Flatten.flattenTree = flattenTree;
    })(Flatten = Tree.Flatten || (Tree.Flatten = {}));
})(Tree || (Tree = {}));

var Tree;
(function (Tree) {
    var Element = (function () {
        function Element(obj) {
            this.anc = obj.anc;
            this.selector = obj.selector;
            this.sel = obj.sel;
        }
        Element.prototype.value = function () {
            return {
                anc: this.anc,
                selector: this.selector,
                sel: this.sel
            };
        };
        return Element;
    })();
    Tree.Element = Element;
    var ListItem = (function () {
        function ListItem(obj) {
            this.anc = obj.anc;
            this.selector = obj.selector;
            this.root = obj.root;
            this.sel = obj.sel;
        }
        ListItem.prototype.value = function () {
            return {
                anc: this.anc,
                selector: this.selector,
                root: this.root,
                sel: this.sel
            };
        };
        return ListItem;
    })();
    Tree.ListItem = ListItem;
    var ItemElement = (function () {
        function ItemElement(obj) {
            this.anc = obj.anc;
            this.selector = obj.selector;
            this.root = obj.root;
            this.sel = obj.sel;
            this.item = obj.item;
        }
        ItemElement.prototype.value = function () {
            return {
                anc: this.anc,
                selector: this.selector,
                root: this.root,
                sel: this.sel,
                item: this.item
            };
        };
        return ItemElement;
    })();
    Tree.ItemElement = ItemElement;
    var ShadowElement = (function () {
        function ShadowElement(obj) {
            this.anc = obj.anc;
            this.selector = obj.selector;
            this.sel = obj.sel;
        }
        ShadowElement.prototype.value = function () {
            return {
                anc: this.anc,
                selector: this.selector,
                sel: this.sel
            };
        };
        return ShadowElement;
    })();
    Tree.ShadowElement = ShadowElement;
    function Analyser() {
        var Parser = htmlparser2.Parser;
        var DomHandler = htmlparser2.DomHandler;
        var handler = new DomHandler();
        var parser = new Parser(handler);
        var analysisDepth = 2;
        var pathTable = {};
        var invertedPathTable = {};
        var pathTableKeys = [];
        function invertPaths() {
            invertedPathTable = R.invertObj(pathTable);
        }
        function getIdFromSelector(selector) {
            return pathTable[selector] ? pathTable[selector] : selector;
        }
        function isValidId(selector) {
            return invertedPathTable[selector] !== void 0;
        }
        function getSelectorFromId(idString) {
            return invertedPathTable[idString] ? invertedPathTable[idString] : idString;
        }
        function getParent(elem) {
            return elem.parent;
        }
        function getName(elem) {
            return elem.name;
        }
        function getType(elem) {
            return elem.type;
        }
        function getNames(elems) {
            return R.map(function (elem) { return getName(elem); }, elems);
        }
        function getChildren(elem) {
            return R.filter(function (s) { return getType(s) === 'tag'; }, elem.children);
        }
        function getTailElement(selector) {
            return R.head(R.split('(', R.last(R.split('>', selector))));
        }
        function hasDuplicateNames(names) {
            return names.length !== R.uniq(names).length;
        }
        function getAttributeValue(elem, name) {
            if (elem.attribs) {
                return elem.attribs[name];
            }
            return void 0;
        }
        function addPaths(elem, root) {
            if (!elem.path) {
                if (root) {
                    elem.path = root + '>' + getName(elem);
                }
                else {
                    elem.path = getName(elem);
                }
            }
            var id = getId(elem);
            if (id)
                pathTable[elem.path] = id;
            var path = elem.path;
            var children = getChildren(elem);
            if (hasDuplicateNames(getNames(children))) {
                R.forEach(function (c) {
                    var id = getId(c);
                    var pos = getChildPosition(c);
                    c.path = path + '>' + numberTag(getName(c), pos);
                    if (id)
                        pathTable[c.path] = id;
                    addPaths(c);
                }, children);
            }
            else {
                R.forEach(function (c) {
                    var id = getId(c);
                    c.path = path + '>' + getName(c);
                    if (id)
                        pathTable[c.path] = id;
                    addPaths(c);
                }, children);
            }
        }
        function optimizePathTable() {
            pathTableKeys = Utils.quicksort(R.keys(pathTable));
        }
        function useSelectorIds(selector) {
            if (!selector)
                return void 0;
            var i = pathTableKeys.length - 1;
            var matched = false;
            while (i >= 0 && !matched) {
                if (selector.length >= pathTableKeys[i].length
                    && selector.substr(0, pathTableKeys[i].length) === pathTableKeys[i]) {
                    matched = true;
                    return pathTable[pathTableKeys[i]] + selector.substr(pathTableKeys[i].length);
                }
                else {
                    i--;
                }
            }
            return selector;
        }
        function replacePathById(element, keys) {
            return R.mapObjIndexed(function (v, key) { return R.contains(key, keys) ? useSelectorIds(v) : v; }, element);
        }
        function getId(elem) {
            var id = getAttributeValue(elem, 'id');
            return id !== void 0
                ? '#' + id
                : void 0;
        }
        function getChildPosition(elem) {
            var children = getChildren(getParent(elem));
            if (R.filter(function (c) { return c.name === elem.name; }, children).length > 1) {
                var pos = 0;
                var head = R.merge({}, elem);
                while (head.prev !== null) {
                    if (head.prev.name === elem.name) {
                        pos++;
                    }
                    head = head.prev;
                }
                return pos;
            }
            else {
                return void 0;
            }
        }
        function numberTag(tag, pos) {
            return pos !== void 0
                ? tag + '(' + pos + ')'
                : tag;
        }
        function relativeElementSelector(selector, root) {
            var minusRoot = selector.substr(root.length + 1);
            var matches = /(.*?)(\(\d+\))?$/.exec(minusRoot);
            return matches[1];
        }
        function isEqualTruncatedArrays(a, b, bTruncatedAt) {
            if (a.length !== b.length)
                return false;
            var truncatedB = R.map(function (item) {
                var chunks = item.split('>');
                return R.take(chunks.length - bTruncatedAt, chunks).join('>');
            }, b);
            return R.difference(a, truncatedB).length === 0;
        }
        function Group() {
            var groups = [];
            function add(candidate, level, greedy) {
                if (greedy === void 0) { greedy = false; }
                groups[level] = groups[level] || [];
                var matched = false;
                var gates = groups[level];
                var len = gates.length;
                var i = -1;
                while (!matched && ++i < len) {
                    var gate = gates[i];
                    if ((gate[1] || greedy) && gate[0] === candidate.name) {
                        _add(gate, candidate, level);
                        matched = true;
                    }
                }
                if (!matched)
                    _createGate(candidate, level);
            }
            function _add(gate, candidate, level) {
                gate[1] = false;
                gate[2].push(candidate.path);
            }
            function _createGate(candidate, level) {
                groups[level].push([candidate.name, false, [candidate.path]]);
            }
            function reset(level) {
                if (groups[level]) {
                    var len = groups.length;
                    var i = level - 1;
                    while (++i < len) {
                        R.forEach(function (tuple) { tuple[1] = true; }, groups[i]);
                    }
                }
            }
            function get() {
                return groups;
            }
            return {
                add: add,
                reset: reset,
                get: get
            };
        }
        function groupChildren(root) {
            var group = Group();
            var level = 0;
            function collect(elem, level) {
                if (level > analysisDepth)
                    return void 0;
                var children = getChildren(elem);
                if (children.length > 0) {
                    level++;
                    var greedy = level === 1
                        ? true
                        : false;
                    R.forEach(function (c) {
                        group.add(c, level, greedy);
                        collect(c, level);
                    }, children);
                    if (level <= 2)
                        group.reset(level);
                }
            }
            group.add(root, level);
            collect(root, level);
            return group.get();
        }
        function extractListItem(root, groups) {
            var listItems = {};
            var shadowElements = {};
            if (groups[1].length === 1) {
                if (groups[1][0][2].length === 1) {
                    var ancTagName = groups[0][0][0];
                    var DOMElemTagName = groups[1][0][0];
                    if (!R.contains((ancTagName, DOMElemTagName), [('ul', 'li'), ('ol', 'li'), ('dl', 'dt')])) {
                        return [{}, {}];
                    }
                }
                var selector = generalizeSelector(R.head(groups[1][0][2]));
                var listItem = new ListItem({
                    anc: root,
                    root: root,
                    selector: selector,
                    sel: elementLast(selector)
                });
                listItems = R.reduce(function (acc, node) {
                    acc[node] = listItem;
                    return acc;
                }, listItems, groups[1][0][2]);
                var chunks = R.split('>', root);
                var shadowElementPaths = {};
                if (/\(\d+\)$/.test(R.last(chunks))) {
                    shadowElementPaths[root] = root;
                    shadowElements = createShadowElementsFromPaths(shadowElementPaths, generalizeSelector(root));
                }
            }
            return [listItems, shadowElements];
        }
        function extractOtherElements(groups, listItemElems) {
            var nrElementsInListItem = groups[1][0][2].length;
            var itemElement;
            var itemElementsOnLevel;
            var elementAncestor;
            var shadowElementPaths = {};
            var level = 2;
            var collection = {};
            if (groups.length <= level)
                return null;
            do {
                itemElementsOnLevel = false;
                R.forEach(function (gate) {
                    if (gate[2].length === nrElementsInListItem) {
                        var elem = R.head(gate[2]);
                        var listItem = R.head(R.values(listItemElems));
                        var _a = generalizeAncestors(listItem, elem), anc = _a[0], selector = _a[1];
                        var sel = elementLast(selector);
                        itemElement = new ItemElement({
                            anc: anc,
                            root: listItem.root,
                            item: listItem.selector,
                            selector: selector,
                            sel: sel
                        });
                        R.forEach(function (elem) {
                            collection[elem] = collection[elem] || [];
                            collection[elem].push(itemElement);
                        }, gate[2]);
                        itemElementsOnLevel = true;
                    }
                    else {
                        R.forEach(function (elem) {
                            var chunks = R.split('>', elem);
                            var anc = R.join('>', R.init(chunks));
                            var listItemSelector = R.join('>', R.take(chunks.length - level + 1, chunks));
                            if (!shadowElementPaths[listItemSelector]) {
                                shadowElementPaths[listItemSelector] = listItemSelector;
                            }
                        }, gate[2]);
                    }
                }, groups[level]);
                level++;
            } while (itemElementsOnLevel && groups.length > level);
            var shadows = createShadowElementsFromPaths(shadowElementPaths, R.prop('selector', R.head(R.values(listItemElems))));
            R.forEach(function (elem) {
                collection[elem] = collection[elem] || [];
                collection[elem].push(shadows[elem]);
            }, R.keys(shadows));
            return collection;
        }
        function generalizeAncestors(listItem, selector) {
            var nrListItemSelectorChunks = R.split('>', listItem.selector).length;
            var selectorChunks = R.split('>', selector);
            var tailChunks = R.drop(nrListItemSelectorChunks, selectorChunks);
            var strippedTail = R.map(R.replace(/\(\d+\)/, ''), R.init(tailChunks));
            var ancestor = listItem.selector + (strippedTail.length > 0
                ? ('>' + R.join('>', strippedTail))
                : '');
            return [ancestor, ancestor + '>' + R.last(tailChunks)];
        }
        function generalizeSelector(selector) {
            var chunks = R.split('>', selector);
            var replaceAnc = R.lensIndex(chunks.length - 1);
            return R.join('>', R.over(replaceAnc, R.replace(/\(\d+\)/, ''), chunks));
        }
        function elementLast(selector) {
            return R.last(R.split('>', selector));
        }
        function createShadowElementsFromPaths(elems, listItemSelector) {
            var collection = {};
            R.forEach(function (elem) {
                var matchSeqNo = /.*\((\d+)\)/.exec(elems[elem]);
                if (matchSeqNo !== null) {
                    var seqNo = matchSeqNo[1];
                    var shadowElement = new ShadowElement({
                        selector: elems[elem],
                        sel: ':' + seqNo,
                        anc: listItemSelector
                    });
                    collection[elem] = shadowElement;
                }
            }, R.keys(elems));
            return collection;
        }
        function analyseGroups(groups, isList) {
            if (groups.length <= 1)
                return null;
            var collection = {};
            var root = R.head(groups[0][0][2]);
            var _a = extractListItem(root, groups), listItemElems = _a[0], shadowElements = _a[1];
            if (R.keys(listItemElems).length === 0)
                return null;
            var otherElems = extractOtherElements(groups, listItemElems);
            R.forEach(function (elem) {
                collection[elem] = collection[elem] || [];
                collection[elem].push(listItemElems[elem]);
            }, R.keys(listItemElems));
            R.forEach(function (elem) {
                collection[elem] = collection[elem] || [];
                collection[elem].push(shadowElements[elem]);
            }, R.keys(shadowElements));
            R.forEach(function (elem) {
                collection[elem] = collection[elem] || [];
                collection[elem] = R.concat(collection[elem], otherElems[elem]);
            }, R.keys(otherElems));
            return collection;
        }
        function addPipInfo(elem, isList) {
            function addInfo(elem, isList) {
                var groups = groupChildren(elem);
                var elementTypes = analyseGroups(groups, isList);
                if (elementTypes === null)
                    return void 0;
                addResultsToNodes(elem, elementTypes);
                R.forEach(function (child) {
                    addInfo(child);
                }, getChildren(elem));
            }
            addInfo(elem, isList);
        }
        function addResultsToNodes(elem, elementTypes) {
            function addResults(elem, elementTypes) {
                var nodeTypeAttrs = elementTypes[elem.path];
                if (nodeTypeAttrs) {
                    R.forEach(function (elementType) {
                        if (elementType instanceof ItemElement)
                            elem.itemElement = elementType;
                        else if (elementType instanceof ListItem) {
                            elem.listItem = elementType;
                            if (elem.parent)
                                elem.parent.isRoot = true;
                        }
                        else if (elementType instanceof ShadowElement)
                            elem.shadowElement = elementType;
                        else if (elementType instanceof Element)
                            elem.element = elementType;
                    }, nodeTypeAttrs);
                }
                R.forEach(function (child) {
                    addResults(child, elementTypes);
                }, getChildren(elem));
            }
            addResults(elem, elementTypes);
        }
        function normalize(elem, rootId) {
            var level = 0;
            optimizePathTable();
            function addNode(elem, parent, rootPath, listItemPath) {
                if (parent === void 0) { parent = { rootPath: [], listItemPath: [] }; }
                if (rootPath === void 0) { rootPath = ''; }
                if (listItemPath === void 0) { listItemPath = ''; }
                var node = { rootPath: [], listItemPath: [] };
                node.rootPath = (rootPath !== '' && rootPath !== R.last(parent.rootPath))
                    ? R.concat(parent.rootPath, [useSelectorIds(rootPath)])
                    : parent.rootPath;
                if (elem.isRoot) {
                    rootPath = useSelectorIds(elem.path);
                }
                node.listItemPath = (listItemPath !== '' && listItemPath !== R.last(parent.listItemPath))
                    ? R.concat(parent.listItemPath, [listItemPath])
                    : parent.listItemPath;
                if (elem.listItem) {
                    listItemPath = elem.listItem.selector;
                }
                if ((!elem.parent || elem.parent.shadowElement || elem.parent.element)
                    && (!elem.element && !elem.listItem && !elem.shadowElement)) {
                    elem.element = new Element({
                        selector: elem.path,
                        sel: elem.parent ? relativeElementSelector(elem.path, elem.parent.path) : elem.path,
                        anc: elem.parent ? elem.parent.path : void 0
                    });
                }
                node.attribs = elem.attribs;
                node.name = elem.name;
                node.isRoot = elem.isRoot;
                if (elem.element)
                    node.element = replacePathById(elem.element.value(), ['selector', 'anc']);
                if (elem.shadowElement)
                    node.shadowElement = replacePathById(elem.shadowElement.value(), ['selector', 'anc']);
                if (elem.listItem)
                    node.listItem = replacePathById(elem.listItem.value(), ['root', 'anc', 'selector']);
                if (elem.itemElement)
                    node.itemElement = replacePathById(elem.itemElement.value(), ['root', 'anc', 'selector', 'item']);
                var children = getChildren(elem);
                node.children = R.map(function (c) { return addNode(c, node, rootPath, listItemPath); }, children);
                return node;
            }
            var tree = addNode(elem);
            return rootId
                ? tree.children
                : tree;
        }
        function showTree(tree) {
            var level = ' ';
            function show(elem) {
                level += ' ';
                R.forEach(function (elem) {
                    console.log(level + elem.name + ' ' + (elem.attribs.id ? elem.attribs.id + ' ' : ' ') + (elem.element ? 'element ' : ' ') + (elem.shadowElement ? 'shadow ' : ' ') + (elem.listItem ? 'listItem ' : ' ') + (elem.itemElement ? 'itemElement ' : ' '));
                    show(elem);
                }, R.filter(function (c) { return c != void 0; }, elem.children));
                level = level.substr(1);
            }
            show(tree);
        }
        function extract(domStr, rootId, isList) {
            var wrappedDomStr = '';
            if (rootId) {
                if (rootId.charAt(0) !== '#')
                    throw new Error("RootId `" + rootId + "` should start with an `#`");
                var rootElem = document.getElementById(rootId.substr(1));
                if (rootElem) {
                    var tag = rootElem.tagName;
                    var id = rootElem.id;
                    wrappedDomStr = "<" + tag + " id=" + id + ">" + domStr + "</" + tag + ">";
                }
            }
            else {
                wrappedDomStr = domStr;
            }
            try {
                parser.reset();
                parser.write(wrappedDomStr);
                parser.end();
            }
            catch (e) {
                console.log(e);
            }
            var elem = handler.dom[0].type === 'tag' ? handler.dom[0] : null;
            if (elem === null)
                return null;
            addPaths(elem);
            invertPaths();
            function walk(elem, isList) {
                addPipInfo(elem, isList);
                R.forEach(function (elem) {
                    walk(elem);
                }, getChildren(elem));
            }
            walk(elem, isList);
            return normalize(elem, rootId);
        }
        return {
            showTree: showTree,
            extract: extract,
            groupChildren: groupChildren,
            getIdFromSelector: getIdFromSelector,
            getSelectorFromId: getSelectorFromId,
            useSelectorIds: useSelectorIds,
            isValidId: isValidId
        };
    }
    Tree.Analyser = Analyser;
})(Tree || (Tree = {}));
